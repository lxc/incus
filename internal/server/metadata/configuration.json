{
	"configs": {
		"cluster": {
			"cluster": {
				"keys": [
					{
						"scheduler.instance": {
							"defaultdesc": "`all`",
							"longdesc": "Possible values are `all`, `manual`, and `group`. See\n{ref}`clustering-instance-placement` for more information.",
							"shortdesc": "Controls how instances are scheduled to run on this member",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "User keys can be used in search.",
							"shortdesc": "Free form user key/value storage",
							"type": "string"
						}
					}
				]
			}
		},
		"devices": {
			"disk": {
				"keys": [
					{
						"attached": {
							"default": "`true`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Only for VMs: Whether the disk is attached or ejected",
							"type": "bool"
						}
					},
					{
						"boot.priority": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Boot priority for VMs (higher value boots first)",
							"type": "integer"
						}
					},
					{
						"ceph.cluster_name": {
							"default": "`ceph`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "The cluster name of the Ceph cluster (required for Ceph or CephFS sources)",
							"type": "string"
						}
					},
					{
						"ceph.user_name": {
							"default": "`admin`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "The user name of the Ceph cluster (required for Ceph or CephFS sources)",
							"type": "string"
						}
					},
					{
						"initial.*": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Initial volume configuration for instance root disk devices",
							"type": "string"
						}
					},
					{
						"io.bus": {
							"default": "`virtio-scsi` for block, `auto` for file system",
							"longdesc": "This controls what bus a disk device should be attached to.\n\nFor block devices (disks), this is one of:\n- `nvme`\n- `virtio-blk`\n- `virtio-scsi` (default)\n- `usb`\n\nFor file systems (shared directories or custom volumes), this is one of:\n- `9p`\n- `auto` (default) (`virtiofs` if possible, else `9p`)\n- `virtiofs`\n\n`9p` doesn't support hotplugging and `virtiofs` doesn't support live migration. `auto` tries\nto use `virtiofs` if possible (`migration.stateful` not set to `true` and host support for\n`virtiofsd`) and falls back to `9p` otherwise.",
							"required": "no",
							"shortdesc": "Only for VMs: Override the bus for the device",
							"type": "string"
						}
					},
					{
						"io.cache": {
							"default": "`none`",
							"longdesc": "This controls what bus a disk device should be attached to.\n\nFor block devices (disks), this is one of:\n- `none` (default)\n- `writeback`\n- `unsafe`\n\nFor file systems (shared directories or custom volumes), this is one of:\n- `none` (default)\n- `metadata`\n- `unsafe`",
							"required": "no",
							"shortdesc": "Only for VMs: Override the caching mode for the device",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "I/O limit in byte/s or IOPS for both read and write (same as setting both `limits.read` and `limits.write`)",
							"type": "string"
						}
					},
					{
						"limits.read": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "I/O limit in byte/s (various suffixes supported, see {ref}`instances-limit-units`) or in IOPS (must be suffixed with `iops`) - see also {ref}`storage-configure-IO`",
							"type": "string"
						}
					},
					{
						"limits.write": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "I/O limit in byte/s (various suffixes supported, see {ref}`instances-limit-units`) or in IOPS (must be suffixed with `iops`) - see also {ref}`storage-configure-IO`",
							"type": "string"
						}
					},
					{
						"path": {
							"longdesc": "This controls which path inside the instance the disk should be mounted on.\n\nWith containers, this option supports mounting file system disk devices, and paths and single files within them.\n\nWith VMs, this option supports mounting file system disk devices and paths within them. Mounting single files is not supported.",
							"required": "yes",
							"shortdesc": "Path inside the instance where the disk will be mounted (only for file system disk devices)",
							"type": "string"
						}
					},
					{
						"pool": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The storage pool to which the disk device belongs (only applicable for storage volumes managed by Incus)",
							"type": "string"
						}
					},
					{
						"propagation": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Controls how a bind-mount is shared between the instance and the host (can be one of `private`, the default, or `shared`, `slave`, `unbindable`,  `rshared`, `rslave`, `runbindable`,  `rprivate`; see the Linux Kernel [shared subtree](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) documentation for a full explanation)",
							"type": "string"
						}
					},
					{
						"raw.mount.options": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "File system specific mount options",
							"type": "string"
						}
					},
					{
						"readonly": {
							"default": "`false`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Controls whether to make the mount read-only",
							"type": "bool"
						}
					},
					{
						"recursive": {
							"default": "`false`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Controls whether to recursively mount the source path",
							"type": "bool"
						}
					},
					{
						"required": {
							"default": "`true`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Controls whether to fail if the source doesn't exist",
							"type": "bool"
						}
					},
					{
						"shift": {
							"default": "`false`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Sets up a shifting overlay to translate the source UID/GID to match the instance (only for containers)",
							"type": "bool"
						}
					},
					{
						"size": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Disk size in bytes (various suffixes supported, see {ref}`instances-limit-units`) - only supported for the `rootfs` (`/`)",
							"type": "string"
						}
					},
					{
						"size.state": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Same as `size`, but applies to the file-system volume used for saving runtime state in VMs",
							"type": "string"
						}
					},
					{
						"source": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "Source of a file system or block device (see {ref}`devices-disk-types` for details)",
							"type": "string"
						}
					},
					{
						"wwn": {
							"default": "``",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Only for VMs: Set the disk World Wide Name (only supported on `virtio-scsi` bus)",
							"type": "bool"
						}
					}
				]
			},
			"gpu_mdev": {
				"keys": [
					{
						"id": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The DRM card ID of the GPU device",
							"type": "string"
						}
					},
					{
						"mdev": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "The mediated device profile to use (required - for example, `i915-GVTg_V5_4`)",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The product ID of the GPU device",
							"type": "string"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The vendor ID of the GPU device",
							"type": "string"
						}
					}
				]
			},
			"gpu_mig": {
				"keys": [
					{
						"id": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The DRM card ID of the GPU device",
							"type": "string"
						}
					},
					{
						"mig.ci": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Existing MIG compute instance ID",
							"type": "int"
						}
					},
					{
						"mig.gi": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Existing MIG GPU instance ID",
							"type": "int"
						}
					},
					{
						"mig.uuid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Existing MIG device UUID (MIG- prefix can be omitted)",
							"type": "string"
						}
					},
					{
						"pci": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The PCI address of the GPU device",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The product ID of the GPU device",
							"type": "string"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The vendor ID of the GPU device",
							"type": "string"
						}
					}
				]
			},
			"gpu_physical": {
				"keys": [
					{
						"gid": {
							"default": "0",
							"longdesc": "",
							"required": "no",
							"shortdesc": "GID of the device owner in the instance (container only)",
							"type": "int"
						}
					},
					{
						"id": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The DRM card ID of the GPU device",
							"type": "string"
						}
					},
					{
						"mode": {
							"default": "0660",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Mode of the device in the instance (container only)",
							"type": "int"
						}
					},
					{
						"pci": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The PCI address of the GPU device",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The product ID of the GPU device",
							"type": "string"
						}
					},
					{
						"uid": {
							"default": "0",
							"longdesc": "",
							"required": "no",
							"shortdesc": "UID of the device owner in the instance (container only)",
							"type": "int"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The vendor ID of the GPU device",
							"type": "string"
						}
					}
				]
			},
			"gpu_sriov": {
				"keys": [
					{
						"id": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The DRM card ID of the parent GPU device",
							"type": "string"
						}
					},
					{
						"pci": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The PCI address of the parent GPU device",
							"type": "string"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The product ID of the parent GPU device",
							"type": "string"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "The vendor ID of the parent GPU device",
							"type": "string"
						}
					}
				]
			},
			"infiniband": {
				"keys": [
					{
						"hwaddr": {
							"defaultdesc": "randomly assigned",
							"longdesc": "",
							"required": "no",
							"shortdesc": "The MAC address of the new interface (can be either the full 20-byte variant or the short 8-byte variant, which will only modify the last 8 bytes of the parent device)",
							"type": "string"
						}
					},
					{
						"mtu": {
							"defaultdesc": "parent MTU",
							"longdesc": "",
							"required": "no",
							"shortdesc": "The MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"required": "no",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"nictype": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "The device type (one of `physical` or `sriov`)",
							"type": "string"
						}
					},
					{
						"parent": {
							"defaultdesc": "kernel assigned",
							"longdesc": "",
							"required": "no",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					}
				]
			},
			"nic_bridged": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Boot priority for VMs (higher value boots first)",
							"type": "integer"
						}
					},
					{
						"host_name": {
							"default": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The name of the interface on the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"io.bus": {
							"default": "`virtio`",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Override the bus for the device (can be `virtio` or `usb`) (VM only)",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "An IPv4 address to assign to the instance through DHCP (can be `none` to restrict all IPv4 traffic when `security.ipv4_filtering` is set)",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv4 static routes to add on host to NIC",
							"type": "string"
						}
					},
					{
						"ipv4.routes.external": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv4 static routes to route to the NIC and publish on uplink network (BGP)",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "An IPv6 address to assign to the instance through DHCP (can be `none` to restrict all IPv6 traffic when `security.ipv6_filtering` is set)",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv6 static routes to add on host to NIC",
							"type": "string"
						}
					},
					{
						"ipv6.routes.external": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv6 static routes to route to the NIC and publish on uplink network (BGP)",
							"type": "string"
						}
					},
					{
						"limits.egress": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "I/O limit in bit/s for outgoing traffic (various suffixes supported, see {ref}instances-limit-units)",
							"type": "string"
						}
					},
					{
						"limits.ingress": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "I/O limit in bit/s for incoming traffic (various suffixes supported, see {ref}instances-limit-units)",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "I/O limit in bit/s for both incoming and outgoing traffic (same as setting both limits.ingress and limits.egress)",
							"type": "string"
						}
					},
					{
						"limits.priority": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The priority for outgoing traffic, to be used by the kernel queuing discipline to prioritize network packets",
							"type": "integer"
						}
					},
					{
						"mtu": {
							"default": "MTU of the parent device",
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The managed network to link the device to (instead of specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The name of the parent host device (required if specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"queue.tx.length": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The transmit queue length for the NIC",
							"type": "integer"
						}
					},
					{
						"security.acls": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-separated list of network ACLs to apply",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.action": {
							"default": "drop",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Action to use for egress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.logged": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Whether to log egress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.acls.default.ingress.action": {
							"default": "drop",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Action to use for ingress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.ingress.logged": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Whether to log ingress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.ipv4_filtering": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Prevent the instance from spoofing another instance's IPv4 address (enables `security.mac_filtering`)",
							"type": "bool"
						}
					},
					{
						"security.ipv6_filtering": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Prevent the instance from spoofing another instance's IPv6 address (enables `security.mac_filtering`)",
							"type": "bool"
						}
					},
					{
						"security.mac_filtering": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Prevent the instance from spoofing another instance's MAC address",
							"type": "bool"
						}
					},
					{
						"security.port_isolation": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Prevent the NIC from communicating with other NICs in the network that have port isolation enabled",
							"type": "bool"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The VLAN ID to use for non-tagged traffic (can be none to remove port from default VLAN)",
							"type": "integer"
						}
					},
					{
						"vlan.tagged": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of VLAN IDs or VLAN ranges to join for tagged traffic",
							"type": "integer"
						}
					}
				]
			},
			"nic_ipvlan": {
				"keys": [
					{
						"gvrp": {
							"default": "false",
							"longdesc": "",
							"shortdesc": "Register VLAN using GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv4 static addresses to add to the instance (in l2 mode, these can be specified as CIDR values or singular addresses using a subnet of /24)",
							"type": "string"
						}
					},
					{
						"ipv4.gateway": {
							"default": "`auto` (in `l3s` mode), `-` (in `l2` mode)",
							"longdesc": "",
							"shortdesc": "In `l3s` mode, whether to add an automatic default IPv4 gateway (can be `auto` or `none`). In `l2` mode, the IPv4 address of the gateway",
							"type": "string"
						}
					},
					{
						"ipv4.host_table": {
							"longdesc": "",
							"shortdesc": "The custom policy routing table ID to add IPv4 static routes to (in addition to the main routing table)",
							"type": "integer"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv6 static addresses to add to the instance (in `l2` mode, these can be specified as CIDR values or singular addresses using a subnet of /64)",
							"type": "string"
						}
					},
					{
						"ipv6.gateway": {
							"default": "`auto` (in `l3s` mode), `-` (in `l2` mode)",
							"longdesc": "",
							"shortdesc": "In `l3s` mode, whether to add an automatic default IPv6 gateway (can be `auto` or `none`). In `l2` mode, the IPv6 address of the gateway",
							"type": "string"
						}
					},
					{
						"ipv6.host_table": {
							"longdesc": "",
							"shortdesc": "The custom policy routing table ID to add IPv6 static routes to (in addition to the main routing table)",
							"type": "integer"
						}
					},
					{
						"mode": {
							"default": "`l3s`",
							"longdesc": "",
							"shortdesc": "The IPVLAN mode (either `l2` or `l3s`)",
							"type": "string"
						}
					},
					{
						"mtu": {
							"default": "MTU of the parent device",
							"longdesc": "",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"shortdesc": "The name of the host device (required)",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"shortdesc": "The VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			},
			"nic_macvlan": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Boot priority for VMs (higher value boots first)",
							"type": "integer"
						}
					},
					{
						"gvrp": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Register VLAN using GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"io.bus": {
							"default": "`virtio`",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Override the bus for the device (can be `virtio` or `usb`) (VM only)",
							"type": "string"
						}
					},
					{
						"mode": {
							"default": "bridge",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Macvlan mode (one of `bridge`, `vepa`, `passthru` or `private`)",
							"type": "string"
						}
					},
					{
						"mtu": {
							"default": "MTU of the parent device",
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The managed network to link the device to (instead of specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The name of the parent host device (required if specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			},
			"nic_ovn": {
				"keys": [
					{
						"acceleration": {
							"default": "none",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Enable hardware offloading (either `none`, `sriov` or `vdpa`)",
							"type": "string"
						}
					},
					{
						"boot.priority": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Boot priority for VMs (higher value boots first)",
							"type": "integer"
						}
					},
					{
						"host_name": {
							"default": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The name of the interface inside the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "An IPv4 address to assign to the instance through DHCP, `none` can be used to disable IP allocation",
							"type": "string"
						}
					},
					{
						"ipv4.address.external": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Select a specific external address (typically from a network forward)",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv4 static routes to route to the NIC",
							"type": "string"
						}
					},
					{
						"ipv4.routes.external": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv4 static routes to route to the NIC and publish on uplink network",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "An IPv6 address to assign to the instance through DHCP, `none` can be used to disable IP allocation",
							"type": "string"
						}
					},
					{
						"ipv6.address.external": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Select a specific external address (typically from a network forward)",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv6 static routes to route to the NIC",
							"type": "string"
						}
					},
					{
						"ipv6.routes.external": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-delimited list of IPv6 static routes to route to the NIC and publish on uplink network",
							"type": "string"
						}
					},
					{
						"mtu": {
							"default": "MTU of the parent network",
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"nested": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The parent NIC name to nest this NIC under (see also `vlan`)",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The managed network to link the device to (required)",
							"type": "string"
						}
					},
					{
						"security.acls": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Comma-separated list of network ACLs to apply",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.action": {
							"default": "reject",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Action to use for egress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.logged": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Whether to log egress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.acls.default.ingress.action": {
							"default": "reject",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Action to use for ingress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.ingress.logged": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Whether to log ingress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.promiscuous": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Have OVN send unknown network traffic to this network interface (required for some nesting cases)",
							"type": "bool"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The VLAN ID to use when nesting (see also `nested`)",
							"type": "integer"
						}
					}
				]
			},
			"nic_p2p": {
				"keys": [
					{
						"boot.priotiry": {
							"longdesc": "",
							"shortdesc": "Boot priority for VMs (higher value boots first)",
							"type": "integer"
						}
					},
					{
						"host_name": {
							"default": "randomly assigned",
							"longdesc": "",
							"shortdesc": "The name of the interface on the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"io.bus": {
							"default": "`virtio`",
							"longdesc": "",
							"shortdesc": "Override the bus for the device (can be `virtio` or `usb`) (VM only)",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv4 static routes to add on host to NIC",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv6 static routes to add on host to NIC",
							"type": "string"
						}
					},
					{
						"limits.egress": {
							"longdesc": "",
							"shortdesc": "I/O limit in bit/s for outgoing traffic (various suffixes supported, see {ref}instances-limit-units)",
							"type": "string"
						}
					},
					{
						"limits.ingress": {
							"longdesc": "",
							"shortdesc": "I/O limit in bit/s for incoming traffic (various suffixes supported, see {ref}instances-limit-units)",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "",
							"shortdesc": "I/O limit in bit/s for both incoming and outgoing traffic (same as setting both limits.ingress and limits.egress)",
							"type": "string"
						}
					},
					{
						"limits.priority": {
							"longdesc": "",
							"shortdesc": "The priority for outgoing traffic, to be used by the kernel queuing discipline to prioritize network packets",
							"type": "integer"
						}
					},
					{
						"mtu": {
							"default": "kernel assigned",
							"longdesc": "",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"queue.tx.length": {
							"longdesc": "",
							"shortdesc": "The transmit queue length for the NIC",
							"type": "integer"
						}
					}
				]
			},
			"nic_physical": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Boot priority for VMs (higher value boots first)",
							"type": "integer"
						}
					},
					{
						"gvrp": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Register VLAN using GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"mtu": {
							"default": "MTU of the parent device",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The managed network to link the device to (instead of specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The name of the parent host device (required if specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			},
			"nic_routed": {
				"keys": [
					{
						"gvrp": {
							"default": "false",
							"longdesc": "",
							"shortdesc": "Register VLAN using GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"host_name": {
							"default": "randomly assigned",
							"longdesc": "",
							"shortdesc": "The name of the interface on the host",
							"type": "string"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"io.bus": {
							"default": "`virtio`",
							"longdesc": "",
							"shortdesc": "Override the bus for the device (can be `virtio` or `usb`) (VM only)",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv4 static addresses to add to the instance",
							"type": "string"
						}
					},
					{
						"ipv4.gateway": {
							"default": "auto",
							"longdesc": "",
							"shortdesc": "Whether to add an automatic default IPv4 gateway (can be `auto` or `none`)",
							"type": "string"
						}
					},
					{
						"ipv4.host_address": {
							"default": "`169.254.0.1`",
							"longdesc": "",
							"shortdesc": "The IPv4 address to add to the host-side `veth` interface",
							"type": "string"
						}
					},
					{
						"ipv4.host_table": {
							"longdesc": "The custom policy routing table ID to add IPv4 static routes to (in addition to the main routing table)\n",
							"shortdesc": "Deprecated: Use `ipv4.host_tables` instead",
							"type": "integer"
						}
					},
					{
						"ipv4.host_tables": {
							"default": "254",
							"longdesc": "",
							"shortdesc": "Comma-delimited list of routing tables IDs to add IPv4 static routes to",
							"type": "string"
						}
					},
					{
						"ipv4.neighbor_probe": {
							"default": "true",
							"longdesc": "",
							"shortdesc": "Whether to probe the parent network for IP address availability",
							"type": "bool"
						}
					},
					{
						"ipv4.routes": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv4 static routes to add on host to NIC (without L2 ARP/NDP proxy)",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv6 static addresses to add to the instance",
							"type": "string"
						}
					},
					{
						"ipv6.gateway": {
							"default": "auto",
							"longdesc": "",
							"shortdesc": "Whether to add an automatic default IPv6 gateway (can be `auto` or `none`)",
							"type": "string"
						}
					},
					{
						"ipv6.host_address": {
							"default": "`fe80::1`",
							"longdesc": "",
							"shortdesc": "The IPv6 address to add to the host-side `veth` interface",
							"type": "string"
						}
					},
					{
						"ipv6.host_table": {
							"longdesc": "The custom policy routing table ID to add IPv6 static routes to (in addition to the main routing table)\n",
							"shortdesc": "Deprecated: Use `ipv6.host_tables` instead",
							"type": "integer"
						}
					},
					{
						"ipv6.host_tables": {
							"default": "254",
							"longdesc": "",
							"shortdesc": "Comma-delimited list of routing tables IDs to add IPv6 static routes to",
							"type": "string"
						}
					},
					{
						"ipv6.neighbor_probe": {
							"default": "true",
							"longdesc": "",
							"shortdesc": "Whether to probe the parent network for IP address availability",
							"type": "bool"
						}
					},
					{
						"ipv6.routes": {
							"longdesc": "",
							"shortdesc": "Comma-delimited list of IPv6 static routes to add on host to NIC (without L2 ARP/NDP proxy)",
							"type": "string"
						}
					},
					{
						"limits.egress": {
							"longdesc": "",
							"shortdesc": "I/O limit in bit/s for outgoing traffic (various suffixes supported, see {ref}instances-limit-units)",
							"type": "string"
						}
					},
					{
						"limits.ingress": {
							"longdesc": "",
							"shortdesc": "I/O limit in bit/s for incoming traffic (various suffixes supported, see {ref}instances-limit-units)",
							"type": "string"
						}
					},
					{
						"limits.max": {
							"longdesc": "",
							"shortdesc": "I/O limit in bit/s for both incoming and outgoing traffic (same as setting both limits.ingress and limits.egress)",
							"type": "string"
						}
					},
					{
						"limits.priority": {
							"longdesc": "",
							"shortdesc": "The priority for outgoing traffic, to be used by the kernel queuing discipline to prioritize network packets",
							"type": "integer"
						}
					},
					{
						"mtu": {
							"default": "parent MTU",
							"longdesc": "",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"shortdesc": "The name of the parent host device to join the instance to",
							"type": "string"
						}
					},
					{
						"queue.tx.length": {
							"longdesc": "",
							"shortdesc": "The transmit queue length for the NIC",
							"type": "integer"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"shortdesc": "The VLAN ID to attach to",
							"type": "integer"
						}
					},
					{
						"vrf": {
							"longdesc": "",
							"shortdesc": "The VRF on the host in which the host-side interface and routes are created",
							"type": "string"
						}
					}
				]
			},
			"nic_sriov": {
				"keys": [
					{
						"boot.priority": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Boot priority for VMs (higher value boots first)",
							"type": "integer"
						}
					},
					{
						"hwaddr": {
							"default": "randomly assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The MAC address of the new interface",
							"type": "string"
						}
					},
					{
						"mtu": {
							"default": "kernel assigned",
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The Maximum Transmit Unit (MTU) of the new interface",
							"type": "integer"
						}
					},
					{
						"name": {
							"default": "kernel assigned",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The name of the interface inside the instance",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The managed network to link the device to (instead of specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"parent": {
							"longdesc": "",
							"managed": "yes",
							"shortdesc": "The name of the parent host device (required if specifying the `nictype` directly)",
							"type": "string"
						}
					},
					{
						"security.mac_filtering": {
							"default": "false",
							"longdesc": "",
							"managed": "no",
							"shortdesc": "Prevent the instance from spoofing another instance's MAC address",
							"type": "bool"
						}
					},
					{
						"vlan": {
							"longdesc": "",
							"managed": "no",
							"shortdesc": "The VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			},
			"pci": {
				"keys": [
					{
						"address": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "PCI address of the device",
							"type": "string"
						}
					}
				]
			},
			"proxy": {
				"keys": [
					{
						"bind": {
							"default": "`host`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Which side to bind on (`host`/`instance`)",
							"type": "string"
						}
					},
					{
						"connect": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "The address and port to connect to (`\u003ctype\u003e:\u003caddr\u003e:\u003cport\u003e[-\u003cport\u003e][,\u003cport\u003e]`)",
							"type": "string"
						}
					},
					{
						"gid": {
							"default": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "GID of the owner of the listening Unix socket",
							"type": "int"
						}
					},
					{
						"listen": {
							"longdesc": "",
							"required": "yes",
							"shortdesc": "The address and port to bind and listen (`\u003ctype\u003e:\u003caddr\u003e:\u003cport\u003e[-\u003cport\u003e][,\u003cport\u003e]`)",
							"type": "string"
						}
					},
					{
						"mode": {
							"default": "`0644`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Mode for the listening Unix socket",
							"type": "int"
						}
					},
					{
						"nat": {
							"default": "`false`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Whether to optimize proxying via NAT (requires that the instance NIC has a static IP address)",
							"type": "bool"
						}
					},
					{
						"proxy_protocol": {
							"default": "`false`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Whether to use the HAProxy PROXY protocol to transmit sender information",
							"type": "bool"
						}
					},
					{
						"security.gid": {
							"default": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "What GID to drop privilege to",
							"type": "int"
						}
					},
					{
						"security.uid": {
							"default": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "What UID to drop privilege to",
							"type": "int"
						}
					},
					{
						"uid": {
							"default": "`0`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "UID of the owner of the listening Unix socket",
							"type": "int"
						}
					}
				]
			},
			"tpm": {
				"keys": [
					{
						"path": {
							"default": "-",
							"longdesc": "",
							"required": "for containers",
							"shortdesc": "Only for containers: path inside the instance (for example, `/dev/tpm0`)",
							"type": "string"
						}
					},
					{
						"pathrm": {
							"default": "-",
							"longdesc": "",
							"required": "for containers",
							"shortdesc": "Only for containers: resource manager path inside the instance (for example, `/dev/tpmrm0`)",
							"type": "string"
						}
					}
				]
			},
			"unix-char-block": {
				"keys": [
					{
						"gid": {
							"default": "0",
							"longdesc": "",
							"shortdesc": "GID of the device owner in the instance",
							"type": "int"
						}
					},
					{
						"major": {
							"default": "device on host",
							"longdesc": "",
							"shortdesc": "Device major number",
							"type": "int"
						}
					},
					{
						"minor": {
							"default": "device on host",
							"longdesc": "",
							"shortdesc": "Device minor number",
							"type": "int"
						}
					},
					{
						"mode": {
							"default": "0660",
							"longdesc": "",
							"shortdesc": "Mode of the device in the instance",
							"type": "int"
						}
					},
					{
						"path": {
							"longdesc": "",
							"shortdesc": "Path inside the instance (one of `source` and `path` must be set)",
							"type": "string"
						}
					},
					{
						"required": {
							"default": "true",
							"longdesc": "",
							"shortdesc": "Whether this device is required to start the instance",
							"type": "bool"
						}
					},
					{
						"source": {
							"longdesc": "",
							"shortdesc": "Path on the host (one of `source` and `path` must be set)",
							"type": "string"
						}
					},
					{
						"uid": {
							"default": "0",
							"longdesc": "",
							"shortdesc": "UID of the device owner in the instance",
							"type": "int"
						}
					}
				]
			},
			"unix-hotplug": {
				"keys": [
					{
						"gid": {
							"default": "0",
							"longdesc": "",
							"shortdesc": "GID of the device owner in the instance",
							"type": "int"
						}
					},
					{
						"mode": {
							"default": "0660",
							"longdesc": "",
							"shortdesc": "Mode of the device in the instance",
							"type": "int"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "The product ID of the USB device",
							"type": "string"
						}
					},
					{
						"required": {
							"default": "true",
							"longdesc": "",
							"shortdesc": "Whether this device is required to start the instance",
							"type": "bool"
						}
					},
					{
						"uid": {
							"default": "0",
							"longdesc": "",
							"shortdesc": "UID of the device owner in the instance",
							"type": "int"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "The vendor ID of the USB device",
							"type": "string"
						}
					}
				]
			},
			"usb": {
				"keys": [
					{
						"busnum": {
							"longdesc": "",
							"shortdesc": "The bus number of which the USB device is attached",
							"type": "int"
						}
					},
					{
						"devnum": {
							"longdesc": "",
							"shortdesc": "The device number of the USB device",
							"type": "int"
						}
					},
					{
						"gid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "Only for containers: GID of the device owner in the instance",
							"type": "int"
						}
					},
					{
						"mode": {
							"defaultdesc": "`0660`",
							"longdesc": "",
							"shortdesc": "Only for containers: Mode of the device in the instance",
							"type": "int"
						}
					},
					{
						"productid": {
							"longdesc": "",
							"shortdesc": "The product ID of the USB device",
							"type": "string"
						}
					},
					{
						"required": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether this device is required to start the instance (the default is `false`, and all devices can be hotplugged)",
							"type": "bool"
						}
					},
					{
						"serial": {
							"longdesc": "",
							"shortdesc": "The serial number of the USB device",
							"type": "string"
						}
					},
					{
						"uid": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"shortdesc": "Only for containers: UID of the device owner in the instance",
							"type": "int"
						}
					},
					{
						"vendorid": {
							"longdesc": "",
							"shortdesc": "The vendor ID of the USB device",
							"type": "string"
						}
					}
				]
			}
		},
		"image": {
			"requirements": {
				"keys": [
					{
						"requirements.cdrom_agent": {
							"longdesc": "",
							"shortdesc": "If set to `true`, indicates that the VM requires an `agent:config` disk be added.",
							"type": "bool"
						}
					},
					{
						"requirements.cgroup": {
							"longdesc": "",
							"shortdesc": "If set to `v1`, indicates that the image requires the host to run cgroup v1.",
							"type": "string"
						}
					},
					{
						"requirements.nesting": {
							"longdesc": "",
							"shortdesc": "If set to `true`, indicates that the image cannot work without nesting enabled.",
							"type": "bool"
						}
					},
					{
						"requirements.privileged": {
							"longdesc": "",
							"shortdesc": "If set to `false`, indicates that the image cannot work as a privileged container.",
							"type": "bool"
						}
					},
					{
						"requirements.secureboot": {
							"longdesc": "",
							"shortdesc": "If set to `false`, indicates that the image cannot boot under secure boot.",
							"type": "bool"
						}
					}
				]
			}
		},
		"instance": {
			"boot": {
				"keys": [
					{
						"boot.autorestart": {
							"liveupdate": "no",
							"longdesc": "If set to `true` will attempt up to 10 restarts over a 1 minute period upon unexpected instance exit.",
							"shortdesc": "Whether to automatically restart an instance on unexpected exit",
							"type": "bool"
						}
					},
					{
						"boot.autostart": {
							"liveupdate": "no",
							"longdesc": "If set to `false`, restore the last state.",
							"shortdesc": "Whether to always start the instance when the daemon starts",
							"type": "bool"
						}
					},
					{
						"boot.autostart.delay": {
							"defaultdesc": "0",
							"liveupdate": "no",
							"longdesc": "The number of seconds to wait after the instance started before starting the next one.",
							"shortdesc": "Delay after starting the instance",
							"type": "integer"
						}
					},
					{
						"boot.autostart.priority": {
							"defaultdesc": "0",
							"liveupdate": "no",
							"longdesc": "The instance with the highest value is started first.",
							"shortdesc": "What order to start the instances in",
							"type": "integer"
						}
					},
					{
						"boot.host_shutdown_action": {
							"defaultdesc": "stop",
							"liveupdate": "yes",
							"longdesc": "Action to take on host shut down\n\nValid values are: `stop`, `force-stop` or `stateful-stop`",
							"shortdesc": "What action to take on the instance when the host is shut down",
							"type": "string"
						}
					},
					{
						"boot.host_shutdown_timeout": {
							"defaultdesc": "30",
							"liveupdate": "yes",
							"longdesc": "Number of seconds to wait for the instance to shut down before it is force-stopped.",
							"shortdesc": "How long to wait for the instance to shut down",
							"type": "integer"
						}
					},
					{
						"boot.stop.priority": {
							"defaultdesc": "0",
							"liveupdate": "no",
							"longdesc": "The instance with the highest value is shut down first.",
							"shortdesc": "What order to shut down the instances in",
							"type": "integer"
						}
					}
				]
			},
			"cloud-init": {
				"keys": [
					{
						"cloud-init.network-config": {
							"condition": "If supported by image",
							"defaultdesc": "`DHCP on eth0`",
							"liveupdate": "no",
							"longdesc": "The content is used as seed value for `cloud-init`.",
							"shortdesc": "Network configuration for `cloud-init`",
							"type": "string"
						}
					},
					{
						"cloud-init.user-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "The content is used as seed value for `cloud-init`.",
							"shortdesc": "User data for `cloud-init`",
							"type": "string"
						}
					},
					{
						"cloud-init.vendor-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "The content is used as seed value for `cloud-init`.",
							"shortdesc": "Vendor data for `cloud-init`",
							"type": "string"
						}
					},
					{
						"user.network-config": {
							"condition": "If supported by image",
							"defaultdesc": "`DHCP on eth0`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Legacy version of `cloud-init.network-config`",
							"type": "string"
						}
					},
					{
						"user.user-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Legacy version of `cloud-init.user-data`",
							"type": "string"
						}
					},
					{
						"user.vendor-data": {
							"condition": "If supported by image",
							"defaultdesc": "`#cloud-config`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Legacy version of `cloud-init.vendor-data`",
							"type": "string"
						}
					}
				]
			},
			"migration": {
				"keys": [
					{
						"migration.incremental.memory": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "Using incremental memory transfer of the instance's memory can reduce downtime.",
							"shortdesc": "Whether to use incremental memory transfer",
							"type": "bool"
						}
					},
					{
						"migration.incremental.memory.goal": {
							"condition": "container",
							"defaultdesc": "`70`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Percentage of memory to have in sync before stopping the instance",
							"type": "integer"
						}
					},
					{
						"migration.incremental.memory.iterations": {
							"condition": "container",
							"defaultdesc": "`10`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Maximum number of transfer operations to go through before stopping the instance",
							"type": "integer"
						}
					},
					{
						"migration.stateful": {
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "Enabling this option prevents the use of some features that are incompatible with it.",
							"shortdesc": "Whether to allow for stateful stop/start and snapshots",
							"type": "bool"
						}
					}
				]
			},
			"miscellaneous": {
				"keys": [
					{
						"agent.nic_config": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "For containers, the name and MTU of the default network interfaces is used for the instance devices.\nFor virtual machines, set this option to `true` to set the name and MTU of the default network interfaces to be the same as the instance devices.",
							"shortdesc": "Whether to use the name and MTU of the default network interfaces",
							"type": "bool"
						}
					},
					{
						"cluster.evacuate": {
							"defaultdesc": "`auto`",
							"liveupdate": "no",
							"longdesc": "The `cluster.evacuate` provides control over how instances are handled when a cluster member is being\nevacuated.\n\nAvailable Modes:\n  - `auto` *(default)*: The system will automatically decide the best evacuation method based on the\n     instance's type and configured devices:\n    + If any device is not suitable for migration, the instance will not be migrated (only stopped).\n    + Live migration will be used only for virtual machines with the `migration.stateful` setting\n      enabled and for which all its devices can be migrated as well.\n  - `live-migrate`: Instances are live-migrated to another server. This means the instance remains running\n     and operational during the migration process, ensuring minimal disruption.\n  - `migrate`: In this mode, instances are migrated to another server in the cluster. The migration\n     process will not be live, meaning there will be a brief downtime for the instance during the\n     migration.\n  -  `stop`: Instances are not migrated. Instead, they are stopped on the current server.\n  -  `stateful-stop`: Instances are not migrated. Instead, they are stopped on the current server\n     but with their runtime state (memory) stored on disk for resuming on restore.\n  -  `force-stop`: Instances are not migrated. Instead, they are forcefully stopped.\n\nSee {ref}`cluster-evacuate` for more information.",
							"shortdesc": "What to do when evacuating the instance",
							"type": "string"
						}
					},
					{
						"environment.*": {
							"liveupdate": "yes",
							"longdesc": "Extra environment variables to set on boot and during exec.",
							"shortdesc": "Free-form environment key/value",
							"type": "string"
						}
					},
					{
						"linux.kernel_modules": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Specify the kernel modules as a comma-separated list.",
							"shortdesc": "Kernel modules to load before starting the instance",
							"type": "string"
						}
					},
					{
						"linux.sysctl.*": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Override for the corresponding `sysctl` setting in the container",
							"type": "string"
						}
					},
					{
						"smbios11.*": {
							"liveupdate": "yes",
							"longdesc": "`SMBIOS Type 11` configuration keys.",
							"shortdesc": "Free-form `SMBIOS Type 11` key/value",
							"type": "string"
						}
					},
					{
						"user.*": {
							"liveupdate": "yes",
							"longdesc": "User keys can be used in search.",
							"shortdesc": "Free-form user key/value storage",
							"type": "string"
						}
					}
				]
			},
			"nvidia": {
				"keys": [
					{
						"nvidia.driver.capabilities": {
							"condition": "container",
							"defaultdesc": "`compute,utility`",
							"liveupdate": "no",
							"longdesc": "The specified driver capabilities are used to set `libnvidia-container NVIDIA_DRIVER_CAPABILITIES`.",
							"shortdesc": "What driver capabilities the instance needs",
							"type": "string"
						}
					},
					{
						"nvidia.require.cuda": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "The specified version expression is used to set `libnvidia-container NVIDIA_REQUIRE_CUDA`.",
							"shortdesc": "Required CUDA version",
							"type": "string"
						}
					},
					{
						"nvidia.require.driver": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "The specified version expression is used to set `libnvidia-container NVIDIA_REQUIRE_DRIVER`.",
							"shortdesc": "Required driver version",
							"type": "string"
						}
					},
					{
						"nvidia.runtime": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to pass the host NVIDIA and CUDA runtime libraries into the instance",
							"type": "bool"
						}
					}
				]
			},
			"raw": {
				"keys": [
					{
						"raw.apparmor": {
							"liveupdate": "yes",
							"longdesc": "The specified entries are appended to the generated profile.",
							"shortdesc": "AppArmor profile entries",
							"type": "blob"
						}
					},
					{
						"raw.idmap": {
							"condition": "unprivileged container",
							"liveupdate": "no",
							"longdesc": "For example: `both 1000 1000`",
							"shortdesc": "Raw idmap configuration",
							"type": "blob"
						}
					},
					{
						"raw.lxc": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Raw LXC configuration to be appended to the generated one",
							"type": "blob"
						}
					},
					{
						"raw.qemu": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Raw QEMU configuration to be appended to the generated command line",
							"type": "blob"
						}
					},
					{
						"raw.qemu.conf": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "See {ref}`instance-options-qemu` for more information.",
							"shortdesc": "Addition/override to the generated `qemu.conf` file",
							"type": "blob"
						}
					},
					{
						"raw.qemu.qmp.early": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "QMP commands to run before Incus QEMU initialization",
							"type": "blob"
						}
					},
					{
						"raw.qemu.qmp.post-start": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "QMP commands to run after the VM has started",
							"type": "blob"
						}
					},
					{
						"raw.qemu.qmp.pre-start": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "QMP commands to run after Incus QEMU initialization and before the VM has started",
							"type": "blob"
						}
					},
					{
						"raw.qemu.scriptlet": {
							"condition": "virtual machine",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "QEMU scriptlet to run at early, pre-start and post-start stages",
							"type": "string"
						}
					},
					{
						"raw.seccomp": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Raw Seccomp configuration",
							"type": "blob"
						}
					}
				]
			},
			"resource-limits": {
				"keys": [
					{
						"limits.cpu": {
							"defaultdesc": "1 (VMs)",
							"liveupdate": "yes",
							"longdesc": "A number or a specific range of CPUs to expose to the instance.\n\nSee {ref}`instance-options-limits-cpu` for more information.",
							"shortdesc": "Which CPUs to expose to the instance",
							"type": "string"
						}
					},
					{
						"limits.cpu.allowance": {
							"condition": "container",
							"defaultdesc": "100%",
							"liveupdate": "yes",
							"longdesc": "To control how much of the CPU can be used, specify either a percentage (`50%`) for a soft limit\nor a chunk of time (`25ms/100ms`) for a hard limit.\n\nSee {ref}`instance-options-limits-cpu-container` for more information.",
							"shortdesc": "How much of the CPU can be used",
							"type": "string"
						}
					},
					{
						"limits.cpu.nodes": {
							"liveupdate": "yes",
							"longdesc": "A comma-separated list of NUMA node IDs or ranges to place the instance CPUs on.\nAlternatively, the value `balanced` may be used to have Incus pick the least busy NUMA node on startup.\n\nSee {ref}`instance-options-limits-cpu-container` for more information.",
							"shortdesc": "Which NUMA nodes to place the instance CPUs on",
							"type": "string"
						}
					},
					{
						"limits.cpu.priority": {
							"condition": "container",
							"defaultdesc": "`10` (maximum)",
							"liveupdate": "yes",
							"longdesc": "When overcommitting resources, specify the CPU scheduling priority compared to other instances that share the same CPUs.\nSpecify an integer between 0 and 10.\n\nSee {ref}`instance-options-limits-cpu-container` for more information.",
							"shortdesc": "CPU scheduling priority compared to other instances",
							"type": "integer"
						}
					},
					{
						"limits.disk.priority": {
							"defaultdesc": "`5` (medium)",
							"liveupdate": "yes",
							"longdesc": "Controls how much priority to give to the instance's I/O requests when under load.\n\nSpecify an integer between 0 and 10.",
							"shortdesc": "Priority of the instance's I/O requests",
							"type": "integer"
						}
					},
					{
						"limits.hugepages.1GB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 1 GB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 1 GB huge pages",
							"type": "string"
						}
					},
					{
						"limits.hugepages.1MB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 1 MB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 1 MB huge pages",
							"type": "string"
						}
					},
					{
						"limits.hugepages.2MB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 2 MB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 2 MB huge pages",
							"type": "string"
						}
					},
					{
						"limits.hugepages.64KB": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Fixed value (in bytes) to limit the number of 64 KB huge pages.\nVarious suffixes are supported (see {ref}`instances-limit-units`).\n\nSee {ref}`instance-options-limits-hugepages` for more information.",
							"shortdesc": "Limit for the number of 64 KB huge pages",
							"type": "string"
						}
					},
					{
						"limits.memory": {
							"defaultdesc": "`1GiB` (VMs)",
							"liveupdate": "yes",
							"longdesc": "Percentage of the host's memory or a fixed value in bytes.\nVarious suffixes are supported.\n\nSee {ref}`instances-limit-units` for details.",
							"shortdesc": "Usage limit for the host's memory",
							"type": "string"
						}
					},
					{
						"limits.memory.enforce": {
							"condition": "container",
							"defaultdesc": "`hard`",
							"liveupdate": "yes",
							"longdesc": "If the instance's memory limit is `hard`, the instance cannot exceed its limit.\nIf it is `soft`, the instance can exceed its memory limit when extra host memory is available.",
							"shortdesc": "Whether the memory limit is `hard` or `soft`",
							"type": "string"
						}
					},
					{
						"limits.memory.hotplug": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "yes",
							"longdesc": "If this option is set to `false`, disable memory hotplug entirely.\nAlternatively, it can be set to a bytes value which will define an upper limit for hotplugged memory.\nThe value must be greater than or equal to limits.memory.",
							"shortdesc": "Control upper limit for hotplugged memory or disable memory hotplug.",
							"type": "string"
						}
					},
					{
						"limits.memory.hugepages": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "If this option is set to `false`, regular system memory is used.",
							"shortdesc": "Whether to back the instance using huge pages",
							"type": "bool"
						}
					},
					{
						"limits.memory.swap": {
							"condition": "container",
							"defaultdesc": "`true`",
							"liveupdate": "yes",
							"longdesc": "When set to `true` or `false`, it controls whether the container is likely to get some of\nits memory swapped by the kernel. Alternatively, it can be set to a bytes value which will\nthen allow the container to make use of additional memory through swap.",
							"shortdesc": "Control swap usage by the instance",
							"type": "string"
						}
					},
					{
						"limits.memory.swap.priority": {
							"condition": "container",
							"defaultdesc": "`10` (maximum)",
							"liveupdate": "yes",
							"longdesc": "Specify an integer between 0 and 10.\nThe higher the value, the less likely the instance is to be swapped to disk.",
							"shortdesc": "Prevents the instance from being swapped to disk",
							"type": "integer"
						}
					},
					{
						"limits.processes": {
							"condition": "container",
							"defaultdesc": "empty",
							"liveupdate": "yes",
							"longdesc": "If left empty, no limit is set.",
							"shortdesc": "Maximum number of processes that can run in the instance",
							"type": "integer"
						}
					}
				]
			},
			"security": {
				"keys": [
					{
						"security.agent.metrics": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether the `incus-agent` is queried for state information and metrics",
							"type": "bool"
						}
					},
					{
						"security.csm": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "When enabling this option, set {config:option}`instance-security:security.secureboot` to `false`.",
							"shortdesc": "Whether to use a firmware that supports UEFI-incompatible operating systems",
							"type": "bool"
						}
					},
					{
						"security.guestapi": {
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "See {ref}`dev-incus` for more information.",
							"shortdesc": "Whether `/dev/incus` is present in the instance",
							"type": "bool"
						}
					},
					{
						"security.guestapi.images": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Controls the availability of the `/1.0/images` API over `guestapi`",
							"type": "bool"
						}
					},
					{
						"security.idmap.base": {
							"condition": "unprivileged container",
							"liveupdate": "no",
							"longdesc": "Setting this option overrides auto-detection.",
							"shortdesc": "The base host ID to use for the allocation",
							"type": "integer"
						}
					},
					{
						"security.idmap.isolated": {
							"condition": "unprivileged container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "If specified, the idmap used for this instance is unique among instances that have this option set.",
							"shortdesc": "Whether to use a unique idmap for this instance",
							"type": "bool"
						}
					},
					{
						"security.idmap.size": {
							"condition": "unprivileged container",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "The size of the idmap to use",
							"type": "integer"
						}
					},
					{
						"security.iommu": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to enable virtual IOMMU, useful for device passthrough and nesting",
							"type": "bool"
						}
					},
					{
						"security.nesting": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Whether to support running Incus (nested) inside the instance",
							"type": "bool"
						}
					},
					{
						"security.privileged": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to run the instance in privileged mode",
							"type": "bool"
						}
					},
					{
						"security.protection.delete": {
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Prevents the instance from being deleted",
							"type": "bool"
						}
					},
					{
						"security.protection.shift": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "Set this option to `true` to prevent the instance's file system from being UID/GID shifted on startup.",
							"shortdesc": "Whether to protect the file system from being UID/GID shifted",
							"type": "bool"
						}
					},
					{
						"security.secureboot": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "When disabling this option, consider enabling {config:option}`instance-security:security.csm`.",
							"shortdesc": "Whether UEFI secure boot is enforced with the default Microsoft keys",
							"type": "bool"
						}
					},
					{
						"security.sev": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether AMD SEV (Secure Encrypted Virtualization) is enabled for this VM",
							"type": "bool"
						}
					},
					{
						"security.sev.policy.es": {
							"condition": "virtual machine",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether AMD SEV-ES (SEV Encrypted State) is enabled for this VM",
							"type": "bool"
						}
					},
					{
						"security.sev.session.data": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "The guest owner's `base64`-encoded session blob",
							"type": "string"
						}
					},
					{
						"security.sev.session.dh": {
							"condition": "virtual machine",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "The guest owner's `base64`-encoded Diffie-Hellman key",
							"type": "string"
						}
					},
					{
						"security.syscalls.allow": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "A `\\n`-separated list of syscalls to allow.\nThis list must be mutually exclusive with `security.syscalls.deny*`.",
							"shortdesc": "List of syscalls to allow",
							"type": "string"
						}
					},
					{
						"security.syscalls.deny": {
							"condition": "container",
							"liveupdate": "no",
							"longdesc": "A `\\n`-separated list of syscalls to deny.\nThis list must be mutually exclusive with `security.syscalls.allow`.",
							"shortdesc": "List of syscalls to deny",
							"type": "string"
						}
					},
					{
						"security.syscalls.deny_compat": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "On `x86_64`, this option controls whether to block `compat_*` syscalls.\nOn other architectures, the option is ignored.",
							"shortdesc": "Whether to block `compat_*` syscalls (`x86_64` only)",
							"type": "bool"
						}
					},
					{
						"security.syscalls.deny_default": {
							"condition": "container",
							"defaultdesc": "`true`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to enable the default syscall deny",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.bpf": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to handle the `bpf()` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.bpf.devices": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This option controls whether to allow BPF programs for the devices cgroup in the unified hierarchy to be loaded.",
							"shortdesc": "Whether to allow BPF programs",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.mknod": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "These system calls allow creation of a limited subset of char/block devices.",
							"shortdesc": "Whether to handle the `mknod` and `mknodat` system calls",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.mount": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to handle the `mount` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.mount.allowed": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Specify a comma-separated list of file systems that are safe to mount for processes inside the instance.",
							"shortdesc": "File systems that can be mounted",
							"type": "string"
						}
					},
					{
						"security.syscalls.intercept.mount.fuse": {
							"condition": "container",
							"liveupdate": "yes",
							"longdesc": "Specify the mounts of a given file system that should be redirected to their FUSE implementation (for example, `ext4=fuse2fs`).",
							"shortdesc": "File system that should be redirected to FUSE implementation",
							"type": "string"
						}
					},
					{
						"security.syscalls.intercept.mount.shift": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "yes",
							"longdesc": "",
							"shortdesc": "Whether to use idmapped mounts for syscall interception",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.sched_setscheduler": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This system call allows increasing process priority.",
							"shortdesc": "Whether to handle the `sched_setscheduler` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.setxattr": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This system call allows setting a limited subset of restricted extended attributes.",
							"shortdesc": "Whether to handle the `setxattr` system call",
							"type": "bool"
						}
					},
					{
						"security.syscalls.intercept.sysinfo": {
							"condition": "container",
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "This system call can be used to get cgroup-based resource usage information.",
							"shortdesc": "Whether to handle the `sysinfo` system call",
							"type": "bool"
						}
					}
				]
			},
			"snapshots": {
				"keys": [
					{
						"snapshots.expiry": {
							"liveupdate": "no",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"shortdesc": "When snapshots are to be deleted",
							"type": "string"
						}
					},
					{
						"snapshots.expiry.manual": {
							"liveupdate": "no",
							"longdesc": "Specify an expression like `1M 2H 3d 4w 5m 6y`.",
							"shortdesc": "When snapshots are to be deleted (for those not created through scheduling)",
							"type": "string"
						}
					},
					{
						"snapshots.pattern": {
							"defaultdesc": "`snap%d`",
							"liveupdate": "no",
							"longdesc": "Specify a Pongo2 template string that represents the snapshot name.\nThis template is used for scheduled snapshots and for unnamed snapshots.\n\nSee {ref}`instance-options-snapshots-names` for more information.",
							"shortdesc": "Template for the snapshot name",
							"type": "string"
						}
					},
					{
						"snapshots.schedule": {
							"defaultdesc": "empty",
							"liveupdate": "no",
							"longdesc": "Specify either a cron expression (`\u003cminute\u003e \u003chour\u003e \u003cdom\u003e \u003cmonth\u003e \u003cdow\u003e`), a comma-and-space-separated list of schedule aliases (`@startup`, `@hourly`, `@daily`, `@midnight`, `@weekly`, `@monthly`, `@annually`, `@yearly`), or leave empty to disable automatic snapshots.\n\nNote that unlike most other configuration keys, this one must be comma-and-space-separated and not just comma-separated as cron expression can themselves contain commas.\n",
							"shortdesc": "Schedule for automatic instance snapshots",
							"type": "string"
						}
					},
					{
						"snapshots.schedule.stopped": {
							"defaultdesc": "`false`",
							"liveupdate": "no",
							"longdesc": "",
							"shortdesc": "Whether to automatically snapshot stopped instances",
							"type": "bool"
						}
					}
				]
			},
			"volatile": {
				"keys": [
					{
						"volatile.\u003cname\u003e.apply_quota": {
							"longdesc": "The disk quota is applied the next time the instance starts.",
							"shortdesc": "Disk quota",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.ceph_rbd": {
							"longdesc": "",
							"shortdesc": "RBD device path for Ceph disk devices",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.host_name": {
							"longdesc": "",
							"shortdesc": "Network device name on the host",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.hwaddr": {
							"longdesc": "The network device MAC address is used when no `hwaddr` property is set on the device itself.",
							"shortdesc": "Network device MAC address",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.io.bus": {
							"longdesc": "The IO bus stores the actual IO bus being used, checked in case `io.bus=auto`.",
							"shortdesc": "IO bus in use",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.created": {
							"longdesc": "Possible values are `true` or `false`.",
							"shortdesc": "Whether the network device physical device was created",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.hwaddr": {
							"longdesc": "The original MAC that was used when moving a physical device into an instance.",
							"shortdesc": "Network device original MAC",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.ip_addresses": {
							"longdesc": "Comma-separated list of the last used IP addresses of the network device.",
							"shortdesc": "Last used IP addresses",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.mtu": {
							"longdesc": "The original MTU that was used when moving a physical device into an instance.",
							"shortdesc": "Network device original MTU",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.pci.driver": {
							"longdesc": "The original host driver for the PCI device.",
							"shortdesc": "PCI original host driver",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.pci.parent": {
							"longdesc": "The parent host device used when allocating a PCI device to an instance.",
							"shortdesc": "PCI parent host device",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.pci.slot.name": {
							"longdesc": "The parent host device PCI slot name.",
							"shortdesc": "PCI parent slot name",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.usb.bus": {
							"longdesc": "The original USB bus address.",
							"shortdesc": "USB bus address",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.usb.device": {
							"longdesc": "The original USB device identifier.",
							"shortdesc": "USB device identifier",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vdpa.name": {
							"longdesc": "The VDPA device name used when moving a VDPA device file descriptor into an instance.",
							"shortdesc": "VDPA device name",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.hwaddr": {
							"longdesc": "The original MAC used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function original MAC",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.id": {
							"longdesc": "The ID used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function ID",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.parent": {
							"longdesc": "The parent host device used when allocating a VF into an instance.",
							"shortdesc": "SR-IOV parent host device",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.spoofcheck": {
							"longdesc": "The original spoof check setting used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function original spoof check setting",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.last_state.vf.vlan": {
							"longdesc": "The original VLAN used when moving a VF into an instance.",
							"shortdesc": "SR-IOV virtual function original VLAN",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.mig.uuid": {
							"longdesc": "The NVIDIA MIG instance UUID.",
							"shortdesc": "MIG instance UUID",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.name": {
							"longdesc": "The network interface name inside of the instance when no `name` property is set on the device itself.",
							"shortdesc": "Network interface name inside of the instance",
							"type": "string"
						}
					},
					{
						"volatile.\u003cname\u003e.vgpu.uuid": {
							"longdesc": "The NVIDIA virtual GPU instance UUID.",
							"shortdesc": "virtual GPU instance UUID",
							"type": "string"
						}
					},
					{
						"volatile.apply_nvram": {
							"longdesc": "",
							"shortdesc": "Whether to regenerate VM NVRAM the next time the instance starts",
							"type": "bool"
						}
					},
					{
						"volatile.apply_template": {
							"longdesc": "The template with the given name is triggered upon next startup.",
							"shortdesc": "Template hook",
							"type": "string"
						}
					},
					{
						"volatile.base_image": {
							"longdesc": "The hash of the image that the instance was created from (empty if the instance was not created from an image).",
							"shortdesc": "Hash of the base image",
							"type": "string"
						}
					},
					{
						"volatile.cloud_init.instance-id": {
							"longdesc": "",
							"shortdesc": "`instance-id` (UUID) exposed to `cloud-init`",
							"type": "string"
						}
					},
					{
						"volatile.cluster.group": {
							"longdesc": "The cluster group(s) that the instance was restricted to at creation time.\nThis is used during re-scheduling events like an evacuation to keep the instance within the requested set.",
							"shortdesc": "The original cluster group for the instance",
							"type": "string"
						}
					},
					{
						"volatile.cpu.nodes": {
							"longdesc": "The NUMA node that was selected for the instance.",
							"shortdesc": "Instance NUMA node",
							"type": "string"
						}
					},
					{
						"volatile.evacuate.origin": {
							"longdesc": "The cluster member that the instance lived on before evacuation.",
							"shortdesc": "The origin of the evacuated instance",
							"type": "string"
						}
					},
					{
						"volatile.idmap.base": {
							"longdesc": "",
							"shortdesc": "The first ID in the instance's primary idmap range",
							"type": "integer"
						}
					},
					{
						"volatile.idmap.current": {
							"longdesc": "",
							"shortdesc": "The idmap currently in use by the instance",
							"type": "string"
						}
					},
					{
						"volatile.idmap.next": {
							"longdesc": "",
							"shortdesc": "The idmap to use the next time the instance starts",
							"type": "string"
						}
					},
					{
						"volatile.last_state.idmap": {
							"longdesc": "",
							"shortdesc": "Serialized instance UID/GID map",
							"type": "string"
						}
					},
					{
						"volatile.last_state.power": {
							"longdesc": "",
							"shortdesc": "Instance state as of last host shutdown",
							"type": "string"
						}
					},
					{
						"volatile.last_state.ready": {
							"longdesc": "",
							"shortdesc": "Instance marked itself as ready",
							"type": "string"
						}
					},
					{
						"volatile.rebalance.last_move": {
							"longdesc": "",
							"shortdesc": "Timestamp of last move by automatic live-migration",
							"type": "integer"
						}
					},
					{
						"volatile.uuid": {
							"longdesc": "The instance UUID is globally unique across all servers and projects.",
							"shortdesc": "Instance UUID",
							"type": "string"
						}
					},
					{
						"volatile.uuid.generation": {
							"longdesc": "The instance generation UUID changes whenever the instance's place in time moves backwards.\nIt is globally unique across all servers and projects.",
							"shortdesc": "Instance generation UUID",
							"type": "string"
						}
					},
					{
						"volatile.vm.definition": {
							"longdesc": "",
							"shortdesc": "QEMU VM definition name (used for migration between versions)",
							"type": "string"
						}
					},
					{
						"volatile.vm.rtc_adjustment": {
							"longdesc": "Real Time Clock adjustment time to allow virtual machines to run on a different base than the host.",
							"shortdesc": "Real Time Clock change adjustment",
							"type": "int64"
						}
					},
					{
						"volatile.vm.rtc_offset": {
							"longdesc": "Real Time Clock offset to allow virtual machines to run on a different base than the host.",
							"shortdesc": "Real Time Clock change offset",
							"type": "int64"
						}
					},
					{
						"volatile.vsock_id": {
							"longdesc": "",
							"shortdesc": "Instance `vsock ID` used as of last start",
							"type": "string"
						}
					}
				]
			}
		},
		"kernel": {
			"limits": {
				"keys": [
					{
						"limits.kernel.as": {
							"longdesc": "",
							"resource": "`RLIMIT_AS`",
							"shortdesc": "Maximum size of the process's virtual memory",
							"type": "string"
						}
					},
					{
						"limits.kernel.core": {
							"longdesc": "",
							"resource": "`RLIMIT_CORE`",
							"shortdesc": "Maximum size of the process's core dump file",
							"type": "string"
						}
					},
					{
						"limits.kernel.cpu": {
							"longdesc": "",
							"resource": "`RLIMIT_CPU`",
							"shortdesc": "Limit in seconds on the amount of CPU time the process can consume",
							"type": "string"
						}
					},
					{
						"limits.kernel.data": {
							"longdesc": "",
							"resource": "`RLIMIT_DATA`",
							"shortdesc": "Maximum size of the process's data segment",
							"type": "string"
						}
					},
					{
						"limits.kernel.fsize": {
							"longdesc": "",
							"resource": "`RLIMIT_FSIZE`",
							"shortdesc": "Maximum size of files the process may create",
							"type": "string"
						}
					},
					{
						"limits.kernel.locks": {
							"longdesc": "",
							"resource": "`RLIMIT_LOCKS`",
							"shortdesc": "Limit on the number of file locks that this process may establish",
							"type": "string"
						}
					},
					{
						"limits.kernel.memlock": {
							"longdesc": "",
							"resource": "`RLIMIT_MEMLOCK`",
							"shortdesc": "Limit on the number of bytes of memory that the process may lock in RAM",
							"type": "string"
						}
					},
					{
						"limits.kernel.nice": {
							"longdesc": "",
							"resource": "`RLIMIT_NICE`",
							"shortdesc": "Maximum value to which the process's nice value can be raised",
							"type": "string"
						}
					},
					{
						"limits.kernel.nofile": {
							"longdesc": "",
							"resource": "`RLIMIT_NOFILE`",
							"shortdesc": "Maximum number of open files for the process",
							"type": "string"
						}
					},
					{
						"limits.kernel.nproc": {
							"longdesc": "",
							"resource": "`RLIMIT_NPROC`",
							"shortdesc": "Maximum number of processes that can be created for the user of the calling process",
							"type": "string"
						}
					},
					{
						"limits.kernel.rtprio": {
							"longdesc": "",
							"resource": "`RLIMIT_RTPRIO`",
							"shortdesc": "Maximum value on the real-time-priority that may be set for this process",
							"type": "string"
						}
					},
					{
						"limits.kernel.sigpending": {
							"longdesc": "",
							"resource": "`RLIMIT_SIGPENDING`",
							"shortdesc": "Limit on the number of bytes of memory that the process may lock in RAM",
							"type": "string"
						}
					}
				]
			}
		},
		"network_bridge": {
			"bgp": {
				"keys": [
					{
						"bgp.peers.NAME.address": {
							"condition": "BGP server",
							"defaultdesc": "-",
							"longdesc": "",
							"shortdesc": "Peer address (IPv4 or IPv6) for use by `ovn` downstream networks",
							"type": "string"
						}
					},
					{
						"bgp.peers.NAME.asn": {
							"condition": "BGP server",
							"defaultdesc": "-",
							"longdesc": "",
							"shortdesc": "Peer AS number for use by `ovn` downstream networks",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.holdtime": {
							"condition": "BGP server",
							"defaultdesc": "`180`",
							"longdesc": "",
							"shortdesc": "Peer session hold time (in seconds; optional)",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.password": {
							"condition": "BGP server",
							"defaultdesc": "- (no password)",
							"longdesc": "",
							"shortdesc": "Peer session password (optional) for use by `ovn` downstream networks",
							"type": "string"
						}
					}
				]
			},
			"common": {
				"keys": [
					{
						"bgp.ipv4.nexthop": {
							"condition": "BGP server",
							"default": "local address",
							"longdesc": "",
							"shortdesc": "Override the next-hop for advertised prefixes",
							"type": "string"
						}
					},
					{
						"bgp.ipv6.nexthop": {
							"condition": "BGP server",
							"default": "local address",
							"longdesc": "",
							"shortdesc": "Override the next-hop for advertised prefixes",
							"type": "string"
						}
					},
					{
						"bridge.driver": {
							"condition": "-",
							"default": "`native`",
							"longdesc": "",
							"shortdesc": "Bridge driver: `native` or `openvswitch`",
							"type": "string"
						}
					},
					{
						"bridge.external_interfaces": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of unconfigured network interfaces to include in the bridge",
							"type": "string"
						}
					},
					{
						"bridge.hwaddr": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "MAC address for the bridge",
							"type": "string"
						}
					},
					{
						"bridge.mtu": {
							"condition": "-",
							"default": "`1500`",
							"longdesc": "",
							"shortdesc": "Bridge MTU (default varies if tunnel in use)",
							"type": "integer"
						}
					},
					{
						"dns.domain": {
							"condition": "-",
							"default": "`incus`",
							"longdesc": "",
							"shortdesc": "Domain to advertise to DHCP clients and use for DNS resolution",
							"type": "string"
						}
					},
					{
						"dns.mode": {
							"condition": "-",
							"default": "`managed`",
							"longdesc": "",
							"shortdesc": "DNS registration mode: none for no DNS record, managed for Incus-generated static records or dynamic for client-generated records",
							"type": "string"
						}
					},
					{
						"dns.nameservers": {
							"condition": "-",
							"default": "IPv4 and IPv6 address",
							"longdesc": "",
							"shortdesc": "DNS server IPs to advertise to DHCP clients and via Router Advertisements. Both IPv4 and IPv6 addresses get pushed via DHCP, and IPv6 addresses are also advertised as RDNSS via RA.",
							"type": "string"
						}
					},
					{
						"dns.search": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Full comma-separated domain search list, defaulting to `dns.domain` value",
							"type": "string"
						}
					},
					{
						"dns.zone.forward": {
							"condition": "-",
							"default": "`managed`",
							"longdesc": "",
							"shortdesc": "Comma-separated list of DNS zone names for forward DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv4": {
							"condition": "-",
							"default": "`managed`",
							"longdesc": "",
							"shortdesc": "DNS zone name for IPv4 reverse DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv6": {
							"condition": "-",
							"default": "`managed`",
							"longdesc": "",
							"shortdesc": "DNS zone name for IPv6 reverse DNS records",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"condition": "standard mode",
							"default": "- (initial value on creation: `auto`)",
							"longdesc": "",
							"shortdesc": "IPv4 address for the bridge (use `none` to turn off IPv4 or `auto` to generate a new random unused subnet) (CIDR)",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp": {
							"condition": "IPv4 address",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to allocate addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv4.dhcp.expiry": {
							"condition": "IPv4 DHCP",
							"default": "`1h`",
							"longdesc": "",
							"shortdesc": "When to expire DHCP leases",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp.gateway": {
							"condition": "IPv4 DHCP",
							"default": "IPv4 address",
							"longdesc": "",
							"shortdesc": "Address of the gateway for the subnet",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp.ranges": {
							"condition": "IPv4 DHCP",
							"default": "all addresses",
							"longdesc": "",
							"shortdesc": "Comma-separated list of IP ranges to use for DHCP (FIRST-LAST format)",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp.routes": {
							"condition": "IPv4 DHCP",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Static routes to provide via DHCP option 121, as a comma-separated list of alternating subnets (CIDR) and gateway addresses (same syntax as dnsmasq)",
							"type": "string"
						}
					},
					{
						"ipv4.firewall": {
							"condition": "IPv4 address",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to generate filtering firewall rules for this network",
							"type": "bool"
						}
					},
					{
						"ipv4.nat": {
							"condition": "IPv4 address",
							"default": "`false`(initial value on creation if `ipv4.address` is set to `auto`: `true`)",
							"longdesc": "",
							"shortdesc": "Whether to NAT",
							"type": "bool"
						}
					},
					{
						"ipv4.nat.address": {
							"condition": "IPv4 address",
							"default": "-",
							"longdesc": "",
							"shortdesc": "The source address used for outbound traffic from the bridge",
							"type": "string"
						}
					},
					{
						"ipv4.nat.order": {
							"condition": "IPv4 address",
							"default": "`before`",
							"longdesc": "",
							"shortdesc": "Whether to add the required NAT rules before or after any pre-existing rules",
							"type": "string"
						}
					},
					{
						"ipv4.ovn.ranges": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of IPv4 ranges to use for child OVN network routers (FIRST-LAST format)",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"condition": "IPv4 address",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of additional IPv4 CIDR subnets to route to the bridge",
							"type": "string"
						}
					},
					{
						"ipv4.routing": {
							"condition": "IPv4 DHCP",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to route traffic in and out of the bridge",
							"type": "bool"
						}
					},
					{
						"ipv6.address": {
							"condition": "standard mode",
							"default": "- (initial value on creation: `auto`)",
							"longdesc": "",
							"shortdesc": "IPv6 address for the bridge (use `none` to turn off IPv6 or `auto` to generate a new random unused subnet) (CIDR)",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp": {
							"condition": "IPv6 DHCP",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to provide additional network configuration over DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.dhcp.expiry": {
							"condition": "IPv6 DHCP",
							"default": "`1h`",
							"longdesc": "",
							"shortdesc": "When to expire DHCP leases",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp.ranges": {
							"condition": "IPv6 stateful DHCP",
							"default": "all addresses",
							"longdesc": "",
							"shortdesc": "Comma-separated list of IPv6 ranges to use for DHCP (FIRST-LAST format)",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp.stateful": {
							"condition": "IPv6 DHCP",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to allocate addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.firewall": {
							"condition": "IPv6 address",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to generate filtering firewall rules for this network",
							"type": "bool"
						}
					},
					{
						"ipv6.nat": {
							"condition": "IPv6 address",
							"default": "`false` (initial value on creation if `ipv6.address` is set to `auto`: `true`)",
							"longdesc": "",
							"shortdesc": "Whether to NAT",
							"type": "bool"
						}
					},
					{
						"ipv6.nat.address": {
							"condition": "IPv6 address",
							"default": "-",
							"longdesc": "",
							"shortdesc": "The source address used for outbound traffic from the bridge",
							"type": "string"
						}
					},
					{
						"ipv6.nat.order": {
							"condition": "IPv6 address",
							"default": "`before`",
							"longdesc": "",
							"shortdesc": "Whether to add the required NAT rules before or after any pre-existing rules",
							"type": "string"
						}
					},
					{
						"ipv6.ovn.ranges": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of IPv6 ranges to use for child OVN network routers (FIRST-LAST format)",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"condition": "IPv6 address",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of additional IPv6 CIDR subnets to route to the bridge",
							"type": "string"
						}
					},
					{
						"ipv6.routing": {
							"condition": "IPv6 address",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to route traffic in and out of the bridge",
							"type": "bool"
						}
					},
					{
						"raw.dnsmasq": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Additional dnsmasq configuration to append to the configuration file",
							"type": "string"
						}
					},
					{
						"security.acls": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of Network ACLs to apply to NICs connected to this network (see {ref}`network-acls-bridge-limitations`)",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.action": {
							"condition": "`security.acls`",
							"default": "`reject`",
							"longdesc": "",
							"shortdesc": "Action to use for egress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.logged": {
							"condition": "`security.acls`",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to log egress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.acls.default.ingress.action": {
							"condition": "`security.acls`",
							"default": "`reject`",
							"longdesc": "",
							"shortdesc": "Action to use for ingress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.ingress.logged": {
							"condition": "`security.acls`",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to log ingress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"tunnel.NAME.group": {
							"condition": "`vxlan`",
							"default": "`239.0.0.1`",
							"longdesc": "",
							"shortdesc": "Multicast address for `vxlan` (used if local and remote aren't set)",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.id": {
							"condition": "`vxlan`",
							"default": "`0`",
							"longdesc": "",
							"shortdesc": "Specific tunnel ID to use for the `vxlan` tunnel",
							"type": "integer"
						}
					},
					{
						"tunnel.NAME.interface": {
							"condition": "`vxlan`",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Specific host interface to use for the tunnel",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.local": {
							"condition": "`gre` or `vxlan`",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Local address for the tunnel (not necessary for multicast `vxlan`)",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.port": {
							"condition": "`vxlan`",
							"default": "`0`",
							"longdesc": "",
							"shortdesc": "Specific port to use for the `vxlan` tunnel",
							"type": "integer"
						}
					},
					{
						"tunnel.NAME.protocol": {
							"condition": "standard mode",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Tunneling protocol: `vxlan` or `gre`",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.remote": {
							"condition": "`gre` or `vxlan`",
							"default": "-",
							"longdesc": "",
							"shortdesc": "Remote address for the tunnel (not necessary for multicast `vxlan`)",
							"type": "string"
						}
					},
					{
						"tunnel.NAME.ttl": {
							"condition": "`vxlan`",
							"default": "`1`",
							"longdesc": "",
							"shortdesc": "Specific TTL to use for multicast routing topologies",
							"type": "integer"
						}
					},
					{
						"user.*": {
							"condition": "-",
							"default": "-",
							"longdesc": "",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			}
		},
		"network_forward": {
			"common": {
				"keys": [
					{
						"target_address": {
							"longdesc": "",
							"shortdesc": "Default target address for anything not covered through a port definition",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"shortdesc": "User defined key/value configuration",
							"type": "string"
						}
					}
				]
			}
		},
		"network_integration": {
			"common": {
				"keys": [
					{
						"user.*": {
							"longdesc": "User keys can be used in search.",
							"shortdesc": "Free form user key/value storage",
							"type": "string"
						}
					}
				]
			},
			"ovn": {
				"keys": [
					{
						"ovn.ca_cert": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL certificate authority for the inter-connection database",
							"type": "string"
						}
					},
					{
						"ovn.client_cert": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL client certificate",
							"type": "string"
						}
					},
					{
						"ovn.client_key": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL client key",
							"type": "string"
						}
					},
					{
						"ovn.northbound_connection": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN northbound inter-connection connection string",
							"type": "string"
						}
					},
					{
						"ovn.southbound_connection": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN southbound inter-connection connection string",
							"type": "string"
						}
					},
					{
						"ovn.transit.pattern": {
							"defaultdesc": "`ts-incus-{{ integrationName }}-{{ projectName }}-{{ networkName }}`",
							"longdesc": "Specify a Pongo2 template string that represents the transit switch name.\nThis template gets access to the project name (`projectName`),\nintegration name (`integrationName`), network name (`networkName`)\nand peer name (`peerName`).\n",
							"shortdesc": "Template for the transit switch name",
							"type": "string"
						}
					}
				]
			}
		},
		"network_load_balancer": {
			"common": {
				"keys": [
					{
						"healthcheck": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to perform checks on the backends",
							"type": "bool"
						}
					},
					{
						"healthcheck.failure_count": {
							"defaultdesc": "`3`",
							"longdesc": "",
							"shortdesc": "Number of failed tests to consider the backend offline",
							"type": "integer"
						}
					},
					{
						"healthcheck.interval": {
							"defaultdesc": "`10`",
							"longdesc": "",
							"shortdesc": "Interval in seconds between health checks",
							"type": "integer"
						}
					},
					{
						"healthcheck.success_count": {
							"defaultdesc": "`3`",
							"longdesc": "",
							"shortdesc": "Number of successful tests to consider the backend online",
							"type": "integer"
						}
					},
					{
						"healthcheck.timeout": {
							"defaultdesc": "`30`",
							"longdesc": "",
							"shortdesc": "Test timeout",
							"type": "integer"
						}
					},
					{
						"user.*": {
							"longdesc": "User keys can be used in search.",
							"shortdesc": "Free form user key/value storage",
							"type": "string"
						}
					}
				]
			}
		},
		"network_macvlan": {
			"common": {
				"keys": [
					{
						"gvrp": {
							"condition": "-",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Register VLAN using GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"mtu": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "The MTU of the new interface",
							"type": "int"
						}
					},
					{
						"parent": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "Parent interface to create macvlan NICs on",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					},
					{
						"vlan": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "The VLAN ID to attach to",
							"type": "int"
						}
					}
				]
			}
		},
		"network_ovn": {
			"common": {
				"keys": [
					{
						"bridge.external_interfaces": {
							"longdesc": "",
							"shortdesc": "Comma-separated list of unconfigured network interfaces to include in the bridge",
							"type": "string"
						}
					},
					{
						"bridge.hwaddr": {
							"longdesc": "",
							"shortdesc": "MAC address for the virtual bridge interface",
							"type": "string"
						}
					},
					{
						"bridge.mtu": {
							"default": "`1442`",
							"longdesc": "",
							"shortdesc": "Bridge MTU (default allows host to host Geneve tunnels)",
							"type": "integer"
						}
					},
					{
						"dns.domain": {
							"default": "`incus`",
							"longdesc": "",
							"shortdesc": "Domain to advertise to DHCP clients and use for DNS resolution",
							"type": "string"
						}
					},
					{
						"dns.nameservers": {
							"default": "Uplink DNS servers (IPv4 and IPv6 address if no uplink is configured)",
							"longdesc": "",
							"shortdesc": "DNS server IPs to advertise to DHCP clients and via Router Advertisements. Both IPv4 and IPv6 addresses get pushed via DHCP, and the first IPv6 address is also advertised as RDNSS via RA.",
							"type": "string"
						}
					},
					{
						"dns.search": {
							"longdesc": "",
							"shortdesc": "Full comma-separated domain search list, defaulting to `dns.domain` value",
							"type": "string"
						}
					},
					{
						"dns.zone.forward": {
							"longdesc": "",
							"shortdesc": "Comma-separated list of DNS zone names for forward DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv4": {
							"longdesc": "",
							"shortdesc": "DNS zone name for IPv4 reverse DNS records",
							"type": "string"
						}
					},
					{
						"dns.zone.reverse.ipv6": {
							"longdesc": "",
							"shortdesc": "DNS zone name for IPv6 reverse DNS records",
							"type": "string"
						}
					},
					{
						"ipv4.address": {
							"condition": "standard mode",
							"default": "(initial value on creation: `auto`)",
							"longdesc": "",
							"shortdesc": "IPv4 address for the bridge (use `none` to turn off IPv4 or `auto` to generate a new random unused subnet) (CIDR)",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp": {
							"condition": "IPv4 address",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to allocate addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv4.dhcp.expiry": {
							"condition": "IPv4 DHCP",
							"default": "`1h`",
							"longdesc": "",
							"shortdesc": "When to expire DHCP leases",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp.ranges": {
							"condition": "IPv4 DHCP",
							"default": "all addresses",
							"longdesc": "",
							"shortdesc": "Comma-separated list of IP ranges to use for DHCP (FIRST-LAST format)",
							"type": "string"
						}
					},
					{
						"ipv4.dhcp.routes": {
							"condition": "IPv4 DHCP",
							"longdesc": "",
							"shortdesc": "Static routes to provide via DHCP option 121, as a comma-separated list of alternating subnets (CIDR) and gateway addresses (same syntax as dnsmasq and OVN)",
							"type": "string"
						}
					},
					{
						"ipv4.l3only": {
							"condition": "IPv4 address",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to enable layer 3 only mode.",
							"type": "bool"
						}
					},
					{
						"ipv4.nat": {
							"condition": "IPv4 address",
							"default": "`false` initial value on creation if `ipv4.address` is set to `auto: true`)",
							"longdesc": "",
							"shortdesc": "Whether to NAT",
							"type": "bool"
						}
					},
					{
						"ipv4.nat.address": {
							"condition": "IPv4 address",
							"longdesc": "",
							"shortdesc": "The source address used for outbound traffic from the network (requires uplink `ovn.ingress_mode=routed`)",
							"type": "string"
						}
					},
					{
						"ipv6.address": {
							"condition": "standard mode",
							"default": "(initial value on creation: `auto`)",
							"longdesc": "",
							"shortdesc": "IPv6 address for the bridge (use `none` to turn off IPv6 or `auto` to generate a new random unused subnet) (CIDR)",
							"type": "string"
						}
					},
					{
						"ipv6.dhcp": {
							"condition": "IPv6 address",
							"default": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to provide additional network configuration over DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.dhcp.stateful": {
							"condition": "IPv6 DHCP",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to allocate addresses using DHCP",
							"type": "bool"
						}
					},
					{
						"ipv6.l3only": {
							"condition": "IPv6 DHCP stateful",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to enable layer 3 only mode.",
							"type": "bool"
						}
					},
					{
						"ipv6.nat": {
							"condition": "IPv6 address",
							"default": "`false` (initial value on creation if `ipv6.address` is set to `auto: true`)",
							"longdesc": "",
							"shortdesc": "Whether to NAT",
							"type": "bool"
						}
					},
					{
						"ipv6.nat.address": {
							"condition": "IPv6 address",
							"longdesc": "",
							"shortdesc": "The source address used for outbound traffic from the network (requires uplink `ovn.ingress_mode=routed`)",
							"type": "string"
						}
					},
					{
						"network": {
							"longdesc": "",
							"shortdesc": "Uplink network to use for external network access or `none` to keep isolated",
							"type": "string"
						}
					},
					{
						"security.acls": {
							"longdesc": "",
							"shortdesc": "Comma-separated list of Network ACLs to apply to NICs connected to this network",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.action": {
							"condition": "`security.acls`",
							"default": "`reject`",
							"longdesc": "",
							"shortdesc": "Action to use for egress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.egress.logged": {
							"condition": "`security.acls`",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to log egress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"security.acls.default.ingress.action": {
							"condition": "`security.acls`",
							"default": "`reject`",
							"longdesc": "",
							"shortdesc": "Action to use for ingress traffic that doesn't match any ACL rule",
							"type": "string"
						}
					},
					{
						"security.acls.default.ingress.logged": {
							"condition": "`security.acls`",
							"default": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to log ingress traffic that doesn't match any ACL rule",
							"type": "bool"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			}
		},
		"network_physical": {
			"bgp": {
				"keys": [
					{
						"bgp.peers.NAME.address": {
							"condition": "BGP server",
							"defaultdesc": "-",
							"longdesc": "",
							"shortdesc": "Peer address (IPv4 or IPv6) for use by `ovn` downstream networks",
							"type": "string"
						}
					},
					{
						"bgp.peers.NAME.asn": {
							"condition": "BGP server",
							"defaultdesc": "-",
							"longdesc": "",
							"shortdesc": "Peer AS number for use by `ovn` downstream networks",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.holdtime": {
							"condition": "BGP server",
							"defaultdesc": "`180`",
							"longdesc": "",
							"shortdesc": "Peer session hold time (in seconds; optional)",
							"type": "integer"
						}
					},
					{
						"bgp.peers.NAME.password": {
							"condition": "BGP server",
							"defaultdesc": "- (no password)",
							"longdesc": "",
							"shortdesc": "Peer session password (optional) for use by `ovn` downstream networks",
							"type": "string"
						}
					}
				]
			},
			"common": {
				"keys": [
					{
						"gvrp": {
							"condition": "-",
							"defaultdesc": "'false'",
							"longdesc": "",
							"shortdesc": "Register VLAN using GARP VLAN Registration Protocol",
							"type": "bool"
						}
					},
					{
						"mtu": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "The MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"parent": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "Existing interface to use for network",
							"type": "string"
						}
					},
					{
						"vlan": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "The VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			},
			"dns": {
				"keys": [
					{
						"dns.nameservers": {
							"condition": "standard mode",
							"longdesc": "",
							"shortdesc": "List of DNS server IPs on `physical` network",
							"type": "string"
						}
					}
				]
			},
			"ipv4": {
				"keys": [
					{
						"ipv4.gateway": {
							"condition": "standard mode",
							"longdesc": "",
							"shortdesc": "IPv4 address for the gateway and network (CIDR)",
							"type": "string"
						}
					},
					{
						"ipv4.gateway.hwaddr": {
							"longdesc": "",
							"shortdesc": "MAC address of the gateway (to avoid discovery)",
							"type": "string"
						}
					},
					{
						"ipv4.ovn.ranges": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of IPv4 ranges to use for child OVN network routers (FIRST-LAST format)",
							"type": "string"
						}
					},
					{
						"ipv4.routes": {
							"condition": "IPv4 address",
							"longdesc": "",
							"shortdesc": "Comma-separated list of additional IPv4 CIDR subnets that can be used with child OVN networks `ipv4.routes.external` setting",
							"type": "string"
						}
					},
					{
						"ipv4.routes.anycast": {
							"condition": "IPv4 address",
							"defaultdesc": "'false'",
							"longdesc": "",
							"shortdesc": "Allow the overlapping routes to be used on multiple networks/NIC at the same time",
							"type": "bool"
						}
					}
				]
			},
			"ipv6": {
				"keys": [
					{
						"ipv6.gateway": {
							"condition": "standard mode",
							"longdesc": "",
							"shortdesc": "IPv6 address for the gateway and network (CIDR)",
							"type": "string"
						}
					},
					{
						"ipv6.gateway.hwaddr": {
							"longdesc": "",
							"shortdesc": "MAC address of the gateway (to avoid discovery)",
							"type": "string"
						}
					},
					{
						"ipv6.ovn.ranges": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "Comma-separated list of IPv6 ranges to use for child OVN network routers (FIRST-LAST format)",
							"type": "string"
						}
					},
					{
						"ipv6.routes": {
							"condition": "IPv6 address",
							"longdesc": "",
							"shortdesc": "Comma-separated list of additional IPv6 CIDR subnets that can be used with child OVN networks `ipv6.routes.external` setting",
							"type": "string"
						}
					},
					{
						"ipv6.routes.anycast": {
							"condition": "IPv6 address",
							"defaultdesc": "'false'",
							"longdesc": "",
							"shortdesc": "Allow the overlapping routes to be used on multiple networks/NIC at the same time",
							"type": "bool"
						}
					}
				]
			},
			"ovn": {
				"keys": [
					{
						"ovn.ingress_mode": {
							"condition": "standard mode",
							"defaultdesc": "`l2proxy`",
							"longdesc": "",
							"shortdesc": "Sets the method how OVN NIC external IPs will be advertised on uplink network: `l2proxy` (proxy ARP/NDP) or `routed`",
							"type": "string"
						}
					}
				]
			}
		},
		"network_sriov": {
			"common": {
				"keys": [
					{
						"mtu": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "The MTU of the new interface",
							"type": "integer"
						}
					},
					{
						"parent": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "Parent interface to create `sriov` NICs on",
							"type": "string"
						}
					},
					{
						"user.*": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					},
					{
						"vlan": {
							"condition": "-",
							"longdesc": "",
							"shortdesc": "The VLAN ID to attach to",
							"type": "integer"
						}
					}
				]
			}
		},
		"network_zone": {
			"common": {
				"keys": [
					{
						"dns.nameservers": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "Comma-separated list of DNS server FQDNs (for NS records)",
							"type": "string set"
						}
					},
					{
						"network.nat": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"required": "no",
							"shortdesc": "Whether to generate records for NAT-ed subnets",
							"type": "bool"
						}
					},
					{
						"peers.NAME.address": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "IP address of a DNS server",
							"type": "string"
						}
					},
					{
						"peers.NAME.key": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "TSIG key for the server",
							"type": "string"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"required": "no",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			}
		},
		"project": {
			"features": {
				"keys": [
					{
						"features.images": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "This setting applies to both images and image aliases.",
							"shortdesc": "Whether to use a separate set of images for the project",
							"type": "bool"
						}
					},
					{
						"features.networks": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of networks for the project",
							"type": "bool"
						}
					},
					{
						"features.networks.zones": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`false`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of network zones for the project",
							"type": "bool"
						}
					},
					{
						"features.profiles": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of profiles for the project",
							"type": "bool"
						}
					},
					{
						"features.storage.buckets": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of storage buckets for the project",
							"type": "bool"
						}
					},
					{
						"features.storage.volumes": {
							"defaultdesc": "`false`",
							"initialvaluedesc": "`true`",
							"longdesc": "",
							"shortdesc": "Whether to use a separate set of storage volumes for the project",
							"type": "bool"
						}
					}
				]
			},
			"limits": {
				"keys": [
					{
						"limits.containers": {
							"longdesc": "",
							"shortdesc": "Maximum number of containers that can be created in the project",
							"type": "integer"
						}
					},
					{
						"limits.cpu": {
							"longdesc": "This value is the maximum value for the sum of the individual {config:option}`instance-resource-limits:limits.cpu` configurations set on the instances of the project.",
							"shortdesc": "Maximum number of CPUs to use in the project",
							"type": "integer"
						}
					},
					{
						"limits.disk": {
							"longdesc": "This value is the maximum value of the aggregate disk space used by all instance volumes, custom volumes, and images of the project.",
							"shortdesc": "Maximum disk space used by the project",
							"type": "string"
						}
					},
					{
						"limits.disk.pool.POOL_NAME": {
							"longdesc": "This value is the maximum value of the aggregate disk\nspace used by all instance volumes, custom volumes, and images of the\nproject on this specific storage pool.",
							"shortdesc": "Maximum disk space used by the project on this pool",
							"type": "string"
						}
					},
					{
						"limits.instances": {
							"longdesc": "",
							"shortdesc": "Maximum number of instances that can be created in the project",
							"type": "integer"
						}
					},
					{
						"limits.memory": {
							"longdesc": "The value is the maximum value for the sum of the individual {config:option}`instance-resource-limits:limits.memory` configurations set on the instances of the project.",
							"shortdesc": "Usage limit for the host's memory for the project",
							"type": "string"
						}
					},
					{
						"limits.networks": {
							"longdesc": "",
							"shortdesc": "Maximum number of networks that the project can have",
							"type": "integer"
						}
					},
					{
						"limits.processes": {
							"longdesc": "This value is the maximum value for the sum of the individual {config:option}`instance-resource-limits:limits.processes` configurations set on the instances of the project.",
							"shortdesc": "Maximum number of processes within the project",
							"type": "integer"
						}
					},
					{
						"limits.virtual-machines": {
							"longdesc": "",
							"shortdesc": "Maximum number of VMs that can be created in the project",
							"type": "integer"
						}
					}
				]
			},
			"restricted": {
				"keys": [
					{
						"restricted": {
							"defaultdesc": "`false`",
							"longdesc": "This option must be enabled to allow the `restricted.*` keys to take effect.\nTo temporarily remove the restrictions, you can disable this option instead of clearing the related keys.",
							"shortdesc": "Whether to block access to security-sensitive features",
							"type": "bool"
						}
					},
					{
						"restricted.backups": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent creating instance or volume backups",
							"type": "string"
						}
					},
					{
						"restricted.cluster.groups": {
							"longdesc": "If specified, this option prevents targeting cluster groups other than the provided ones.",
							"shortdesc": "Cluster groups that can be targeted",
							"type": "string"
						}
					},
					{
						"restricted.cluster.target": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, this option allows targeting of cluster members (either directly or via a group) when creating or moving instances.",
							"shortdesc": "Whether to prevent targeting of cluster members",
							"type": "string"
						}
					},
					{
						"restricted.containers.interception": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow`, `block`, or `full`.\nWhen set to `allow`, interception options that are usually safe are allowed.\nFile system mounting remains blocked.",
							"shortdesc": "Whether to prevent using system call interception options",
							"type": "string"
						}
					},
					{
						"restricted.containers.lowlevel": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, low-level container options like {config:option}`instance-raw:raw.lxc`, {config:option}`instance-raw:raw.idmap`, `volatile.*`, etc. can be used.",
							"shortdesc": "Whether to prevent using low-level container options",
							"type": "string"
						}
					},
					{
						"restricted.containers.nesting": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, {config:option}`instance-security:security.nesting` can be set to `true` for an instance.",
							"shortdesc": "Whether to prevent running nested Incus",
							"type": "string"
						}
					},
					{
						"restricted.containers.privilege": {
							"defaultdesc": "`unprivileged`",
							"longdesc": "Possible values are `unprivileged`, `isolated`, and `allow`.\n\n- When set to `unprivileged`, this option prevents setting {config:option}`instance-security:security.privileged` to `true`.\n- When set to `isolated`, this option prevents setting {config:option}`instance-security:security.privileged` and {config:option}`instance-security:security.idmap.isolated` to `true`.\n- When set to `allow`, there is no restriction.",
							"shortdesc": "Which settings for privileged containers to prevent",
							"type": "string"
						}
					},
					{
						"restricted.devices.disk": {
							"defaultdesc": "`managed`",
							"longdesc": "Possible values are `allow`, `block`, or `managed`.\n\n- When set to `block`, this option prevents using all disk devices except the root one.\n- When set to `managed`, this option allows using disk devices only if `pool=` is set.\n- When set to `allow`, there is no restriction on which disk devices can be used.",
							"shortdesc": "Which disk devices can be used",
							"type": "string"
						}
					},
					{
						"restricted.devices.disk.paths": {
							"longdesc": "If {config:option}`project-restricted:restricted.devices.disk` is set to `allow`, this option controls which `source` can be used for `disk` devices.\nSpecify a comma-separated list of path prefixes that restrict the `source` setting.\nIf this option is left empty, all paths are allowed.",
							"shortdesc": "Which `source` can be used for `disk` devices",
							"type": "string"
						}
					},
					{
						"restricted.devices.gpu": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `gpu`",
							"type": "string"
						}
					},
					{
						"restricted.devices.infiniband": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `infiniband`",
							"type": "string"
						}
					},
					{
						"restricted.devices.nic": {
							"defaultdesc": "`managed`",
							"longdesc": "Possible values are `allow`, `block`, or `managed`.\n\n- When set to `block`, this option prevents using all network devices.\n- When set to `managed`, this option allows using network devices only if `network=` is set.\n- When set to `allow`, there is no restriction on which network devices can be used.",
							"shortdesc": "Which network devices can be used",
							"type": "string"
						}
					},
					{
						"restricted.devices.pci": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `pci`",
							"type": "string"
						}
					},
					{
						"restricted.devices.proxy": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `proxy`",
							"type": "string"
						}
					},
					{
						"restricted.devices.unix-block": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `unix-block`",
							"type": "string"
						}
					},
					{
						"restricted.devices.unix-char": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `unix-char`",
							"type": "string"
						}
					},
					{
						"restricted.devices.unix-hotplug": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `unix-hotplug`",
							"type": "string"
						}
					},
					{
						"restricted.devices.usb": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.",
							"shortdesc": "Whether to prevent using devices of type `usb`",
							"type": "string"
						}
					},
					{
						"restricted.idmap.gid": {
							"longdesc": "This option specifies the host GID ranges that are allowed in the instance's {config:option}`instance-raw:raw.idmap` setting.",
							"shortdesc": "Which host GID ranges are allowed in `raw.idmap`",
							"type": "string"
						}
					},
					{
						"restricted.idmap.uid": {
							"longdesc": "This option specifies the host UID ranges that are allowed in the instance's {config:option}`instance-raw:raw.idmap` setting.",
							"shortdesc": "Which host UID ranges are allowed in `raw.idmap`",
							"type": "string"
						}
					},
					{
						"restricted.networks.access": {
							"longdesc": "Specify a comma-delimited list of network names that are allowed for use in this project.\nIf this option is not set, all networks are accessible.\n\nNote that this setting depends on the {config:option}`project-restricted:restricted.devices.nic` setting.",
							"shortdesc": "Which network names are allowed for use in this project",
							"type": "string"
						}
					},
					{
						"restricted.networks.integrations": {
							"longdesc": "Specify a comma-delimited list of network integrations that can be used by networks in this project.",
							"shortdesc": "Which network integrations can be used in this project",
							"type": "string"
						}
					},
					{
						"restricted.networks.subnets": {
							"defaultdesc": "`block`",
							"longdesc": "Specify a comma-delimited list of network subnets from the uplink networks that are allocated for use in this project.\nUse the form `\u003cuplink\u003e:\u003csubnet\u003e`.",
							"shortdesc": "Which network subnets are allocated for use in this project",
							"type": "string"
						}
					},
					{
						"restricted.networks.uplinks": {
							"longdesc": "Specify a comma-delimited list of network names that can be used as uplink for networks in this project.",
							"shortdesc": "Which network names can be used as uplink in this project",
							"type": "string"
						}
					},
					{
						"restricted.networks.zones": {
							"defaultdesc": "`block`",
							"longdesc": "Specify a comma-delimited list of network zones that can be used (or something under them) in this project.",
							"shortdesc": "Which network zones can be used in this project",
							"type": "string"
						}
					},
					{
						"restricted.snapshots": {
							"defaultdesc": "`block`",
							"longdesc": "",
							"shortdesc": "Whether to prevent creating instance or volume snapshots",
							"type": "string"
						}
					},
					{
						"restricted.virtual-machines.lowlevel": {
							"defaultdesc": "`block`",
							"longdesc": "Possible values are `allow` or `block`.\nWhen set to `allow`, low-level VM options like {config:option}`instance-raw:raw.qemu`, `volatile.*`, etc. can be used.",
							"shortdesc": "Whether to prevent using low-level VM options",
							"type": "string"
						}
					}
				]
			},
			"specific": {
				"keys": [
					{
						"backups.compression_algorithm": {
							"longdesc": "Specify which compression algorithm to use for backups in this project.\nPossible values are `bzip2`, `gzip`, `lz4`, `lzma`, `xz`, `zstd` or `none`.",
							"shortdesc": "Compression algorithm to use for backups",
							"type": "string"
						}
					},
					{
						"images.auto_update_cached": {
							"longdesc": "",
							"shortdesc": "Whether to automatically update cached images in the project",
							"type": "bool"
						}
					},
					{
						"images.auto_update_interval": {
							"longdesc": "Specify the interval in hours.\nTo disable looking for updates to cached images, set this option to `0`.",
							"shortdesc": "Interval at which to look for updates to cached images",
							"type": "integer"
						}
					},
					{
						"images.compression_algorithm": {
							"longdesc": "Possible values are `bzip2`, `gzip`, `lz4`, `lzma`, `xz`, `zstd` or `none`.",
							"shortdesc": "Compression algorithm to use for new images in the project",
							"type": "string"
						}
					},
					{
						"images.default_architecture": {
							"longdesc": "",
							"shortdesc": "Default architecture to use in a mixed-architecture cluster",
							"type": "string"
						}
					},
					{
						"images.remote_cache_expiry": {
							"longdesc": "Specify the number of days after which the unused cached image expires.",
							"shortdesc": "When an unused cached remote image is flushed in the project",
							"type": "integer"
						}
					},
					{
						"user.*": {
							"longdesc": "",
							"shortdesc": "User-provided free-form key/value pairs",
							"type": "string"
						}
					}
				]
			}
		},
		"server": {
			"acme": {
				"keys": [
					{
						"acme.agree_tos": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Agree to ACME terms of service",
							"type": "bool"
						}
					},
					{
						"acme.ca_url": {
							"defaultdesc": "`https://acme-v02.api.letsencrypt.org/directory`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "URL to the directory resource of the ACME service",
							"type": "string"
						}
					},
					{
						"acme.challenge": {
							"defaultdesc": "`HTTP-01`",
							"longdesc": "Possible values are `DNS-01` and `HTTP-01`.",
							"scope": "global",
							"shortdesc": "ACME challenge type to use",
							"type": "string"
						}
					},
					{
						"acme.domain": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Domain for which the certificate is issued",
							"type": "string"
						}
					},
					{
						"acme.email": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Email address used for the account registration",
							"type": "string"
						}
					},
					{
						"acme.http.port": {
							"defaultdesc": "`:80`",
							"longdesc": "Set the port and interface to use for HTTP-01 based challenges to listen on",
							"scope": "global",
							"shortdesc": "Port and interface for HTTP server (used by HTTP-01)",
							"type": "string"
						}
					},
					{
						"acme.provider": {
							"defaultdesc": "``",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Backend provider for the challenge (used by DNS-01)",
							"type": "string"
						}
					},
					{
						"acme.provider.environment": {
							"defaultdesc": "``",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Environment variables to set during the challenge (used by DNS-01)",
							"type": "string"
						}
					},
					{
						"acme.provider.resolvers": {
							"defaultdesc": "``",
							"longdesc": "DNS resolvers to use for performing (recursive) `CNAME` resolving and apex domain determination during DNS-01 challenge.",
							"scope": "global",
							"shortdesc": "Comma-separated list of DNS resolvers (used by DNS-01)",
							"type": "string"
						}
					}
				]
			},
			"cluster": {
				"keys": [
					{
						"cluster.healing_threshold": {
							"defaultdesc": "`0`",
							"longdesc": "Specify the number of seconds after which an offline cluster member is to be evacuated.\nTo disable evacuating offline members, set this option to `0`.",
							"scope": "global",
							"shortdesc": "Threshold when to evacuate an offline cluster member",
							"type": "integer"
						}
					},
					{
						"cluster.https_address": {
							"longdesc": "See {ref}`cluster-https-address`.",
							"scope": "local",
							"shortdesc": "Address to use for clustering traffic",
							"type": "string"
						}
					},
					{
						"cluster.images_minimal_replica": {
							"defaultdesc": "`3`",
							"longdesc": "Specify the minimal number of cluster members that keep a copy of a particular image.\nSet this option to `1` for no replication, or to `-1` to replicate images on all members.",
							"scope": "global",
							"shortdesc": "Number of cluster members that replicate an image",
							"type": "integer"
						}
					},
					{
						"cluster.join_token_expiry": {
							"defaultdesc": "`3H`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Time after which a cluster join token expires",
							"type": "string"
						}
					},
					{
						"cluster.max_standby": {
							"defaultdesc": "`2`",
							"longdesc": "Specify the maximum number of cluster members that are assigned the database stand-by role.\nThis must be a number between `0` and `5`.",
							"scope": "global",
							"shortdesc": "Number of database stand-by members",
							"type": "integer"
						}
					},
					{
						"cluster.max_voters": {
							"defaultdesc": "`3`",
							"longdesc": "Specify the maximum number of cluster members that are assigned the database voter role.\nThis must be an odd number \u003e= `3`.",
							"scope": "global",
							"shortdesc": "Number of database voter members",
							"type": "integer"
						}
					},
					{
						"cluster.offline_threshold": {
							"defaultdesc": "`20`",
							"longdesc": "Specify the number of seconds after which an unresponsive member is considered offline.",
							"scope": "global",
							"shortdesc": "Threshold when an unresponsive member is considered offline",
							"type": "integer"
						}
					},
					{
						"cluster.rebalance.batch": {
							"defaultdesc": "`1`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Maximum number of instances to move during one re-balancing run",
							"type": "integer"
						}
					},
					{
						"cluster.rebalance.cooldown": {
							"defaultdesc": "`6H`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Amount of time during which an instance will not be moved again",
							"type": "string"
						}
					},
					{
						"cluster.rebalance.interval": {
							"defaultdesc": "`0`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "How often (in minutes) to consider re-balancing things. 0 to disable (default)",
							"type": "integer"
						}
					},
					{
						"cluster.rebalance.threshold": {
							"defaultdesc": "`20`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Percentage load difference between most and least busy server needed to trigger a migration",
							"type": "integer"
						}
					}
				]
			},
			"core": {
				"keys": [
					{
						"core.bgp_address": {
							"longdesc": "See {ref}`network-bgp`.",
							"scope": "local",
							"shortdesc": "Address to bind the BGP server to",
							"type": "string"
						}
					},
					{
						"core.bgp_asn": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "BGP Autonomous System Number for the local server",
							"type": "string"
						}
					},
					{
						"core.bgp_routerid": {
							"longdesc": "The identifier must be formatted as an IPv4 address.",
							"scope": "local",
							"shortdesc": "A unique identifier for the BGP server",
							"type": "string"
						}
					},
					{
						"core.debug_address": {
							"longdesc": "",
							"scope": "local",
							"shortdesc": "Address to bind the `pprof` debug server to (HTTP)",
							"type": "string"
						}
					},
					{
						"core.dns_address": {
							"longdesc": "See {ref}`network-dns-server`.",
							"scope": "local",
							"shortdesc": "Address to bind the authoritative DNS server to",
							"type": "string"
						}
					},
					{
						"core.https_address": {
							"longdesc": "See {ref}`server-expose`.",
							"scope": "local",
							"shortdesc": "Address to bind for the remote API (HTTPS)",
							"type": "string"
						}
					},
					{
						"core.https_allowed_credentials": {
							"defaultdesc": "`false`",
							"longdesc": "If enabled, the `Access-Control-Allow-Credentials` HTTP header value is set to `true`.",
							"scope": "global",
							"shortdesc": "Whether to set `Access-Control-Allow-Credentials`",
							"type": "bool"
						}
					},
					{
						"core.https_allowed_headers": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "`Access-Control-Allow-Headers` HTTP header value",
							"type": "string"
						}
					},
					{
						"core.https_allowed_methods": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "`Access-Control-Allow-Methods` HTTP header value",
							"type": "string"
						}
					},
					{
						"core.https_allowed_origin": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "`Access-Control-Allow-Origin` HTTP header value",
							"type": "string"
						}
					},
					{
						"core.https_trusted_proxy": {
							"longdesc": "Specify a comma-separated list of IP addresses of trusted servers that provide the client's address through the proxy connection header.",
							"scope": "global",
							"shortdesc": "Trusted servers to provide the client's address",
							"type": "string"
						}
					},
					{
						"core.metrics_address": {
							"longdesc": "See {ref}`metrics`.",
							"scope": "local",
							"shortdesc": "Address to bind the metrics server to (HTTPS)",
							"type": "string"
						}
					},
					{
						"core.metrics_authentication": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to enforce authentication on the metrics endpoint",
							"type": "bool"
						}
					},
					{
						"core.proxy_http": {
							"longdesc": "If this option is not specified, the daemon falls back to the `HTTP_PROXY` environment variable (if set).",
							"scope": "global",
							"shortdesc": "HTTP proxy to use",
							"type": "string"
						}
					},
					{
						"core.proxy_https": {
							"longdesc": "If this option is not specified, the daemon falls back to the `HTTPS_PROXY` environment variable (if set).",
							"scope": "global",
							"shortdesc": "HTTPS proxy to use",
							"type": "string"
						}
					},
					{
						"core.proxy_ignore_hosts": {
							"longdesc": "Specify this option in a similar format to `NO_PROXY` (for example, `1.2.3.4,1.2.3.5`)\n\nIf this option is not specified, the daemon falls back to the `NO_PROXY` environment variable (if set).",
							"scope": "global",
							"shortdesc": "Hosts that don't need the proxy",
							"type": "string"
						}
					},
					{
						"core.remote_token_expiry": {
							"defaultdesc": "no expiry",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Time after which a remote add token expires",
							"type": "string"
						}
					},
					{
						"core.shutdown_timeout": {
							"defaultdesc": "`5`",
							"longdesc": "Specify the number of minutes to wait for running operations to complete before the daemon shuts down.",
							"scope": "global",
							"shortdesc": "How long to wait before shutdown",
							"type": "integer"
						}
					},
					{
						"core.storage_buckets_address": {
							"longdesc": "See {ref}`howto-storage-buckets`.",
							"scope": "local",
							"shortdesc": "Address to bind the storage object server to (HTTPS)",
							"type": "string"
						}
					},
					{
						"core.syslog_socket": {
							"defaultdesc": "`false`",
							"longdesc": "Set this option to `true` to enable the syslog unixgram socket to receive log messages from external processes.",
							"scope": "local",
							"shortdesc": "Whether to enable the syslog unixgram socket listener",
							"type": "bool"
						}
					},
					{
						"core.trust_ca_certificates": {
							"defaultdesc": "`false`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to automatically trust clients signed by the CA",
							"type": "bool"
						}
					}
				]
			},
			"images": {
				"keys": [
					{
						"images.auto_update_cached": {
							"defaultdesc": "`true`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Whether to automatically update cached images",
							"type": "bool"
						}
					},
					{
						"images.auto_update_interval": {
							"defaultdesc": "`6`",
							"longdesc": "Specify the interval in hours.\nTo disable looking for updates to cached images, set this option to `0`.",
							"scope": "global",
							"shortdesc": "Interval at which to look for updates to cached images",
							"type": "integer"
						}
					},
					{
						"images.compression_algorithm": {
							"defaultdesc": "`gzip`",
							"longdesc": "Possible values are `bzip2`, `gzip`, `lz4`, `lzma`, `xz`, `zstd` or `none`.",
							"scope": "global",
							"shortdesc": "Compression algorithm to use for new images",
							"type": "string"
						}
					},
					{
						"images.default_architecture": {
							"longdesc": "",
							"shortdesc": "Default architecture to use in a mixed-architecture cluster",
							"type": "string"
						}
					},
					{
						"images.remote_cache_expiry": {
							"defaultdesc": "`10`",
							"longdesc": "Specify the number of days after which the unused cached image expires.",
							"scope": "global",
							"shortdesc": "When an unused cached remote image is flushed",
							"type": "integer"
						}
					}
				]
			},
			"logging": {
				"keys": [
					{
						"logging.NAME.lifecycle.projects": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Comma separate list of projects, empty means all",
							"type": "string"
						}
					},
					{
						"logging.NAME.lifecycle.types": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "E.g., `instance`, comma separate, empty means all",
							"type": "string"
						}
					},
					{
						"logging.NAME.logging.level": {
							"defaultdesc": "`info`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Minimum log level to send to the logger",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.address": {
							"longdesc": "Specify the protocol, name or IP and port. For example `tcp://syslog01.int.example.net:514`.",
							"scope": "global",
							"shortdesc": "Address of the logger",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.ca_cert": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "CA certificate for the server",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.facility": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The syslog facility defines the category of the log message",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.instance": {
							"defaultdesc": "Local server host name or cluster member name",
							"longdesc": "This allows replacing the default instance value (server host name) by a more relevant value like a cluster identifier.",
							"scope": "global",
							"shortdesc": "Name to use as the instance field in Loki events.",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.labels": {
							"longdesc": "Specify a comma-separated list of values that should be used as labels for a Loki log entry.",
							"scope": "global",
							"shortdesc": "Labels for a Loki log entry",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.password": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Password used for authentication",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.retry": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "number of delivery retries, default 3",
							"type": "integer"
						}
					},
					{
						"logging.NAME.target.type": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "The type of the logger. One of `loki`, `syslog` or `webhook`.",
							"type": "string"
						}
					},
					{
						"logging.NAME.target.username": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User name used for authentication",
							"type": "string"
						}
					},
					{
						"logging.NAME.types": {
							"defaultdesc": "`lifecycle,logging`",
							"longdesc": "Specify a comma-separated list of events to send to the logger.\nThe events can be any combination of `lifecycle`, `logging`, and `network-acl`.",
							"scope": "global",
							"shortdesc": "Events to send to the logger",
							"type": "string"
						}
					}
				]
			},
			"loki": {
				"keys": [
					{
						"loki.api.ca_cert": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "CA certificate for the Loki server",
							"type": "string"
						}
					},
					{
						"loki.api.url": {
							"longdesc": "Specify the protocol, name or IP and port. For example `https://loki.example.com:3100`. Incus will automatically add the `/loki/api/v1/push` suffix so there's no need to add it here.",
							"scope": "global",
							"shortdesc": "URL to the Loki server",
							"type": "string"
						}
					},
					{
						"loki.auth.password": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Password used for Loki authentication",
							"type": "string"
						}
					},
					{
						"loki.auth.username": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "User name used for Loki authentication",
							"type": "string"
						}
					},
					{
						"loki.instance": {
							"defaultdesc": "Local server host name or cluster member name",
							"longdesc": "This allows replacing the default instance value (server host name) by a more relevant value like a cluster identifier.",
							"scope": "global",
							"shortdesc": "Name to use as the instance field in Loki events.",
							"type": "string"
						}
					},
					{
						"loki.labels": {
							"longdesc": "Specify a comma-separated list of values that should be used as labels for a Loki log entry.",
							"scope": "global",
							"shortdesc": "Labels for a Loki log entry",
							"type": "string"
						}
					},
					{
						"loki.loglevel": {
							"defaultdesc": "`info`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Minimum log level to send to the Loki server",
							"type": "string"
						}
					},
					{
						"loki.types": {
							"defaultdesc": "`lifecycle,logging`",
							"longdesc": "Specify a comma-separated list of events to send to the Loki server.\nThe events can be any combination of `lifecycle`, `logging`, and `network-acl`.",
							"scope": "global",
							"shortdesc": "Events to send to the Loki server",
							"type": "string"
						}
					}
				]
			},
			"miscellaneous": {
				"keys": [
					{
						"authorization.scriptlet": {
							"longdesc": "When using scriptlet-based authorization, this option stores the scriptlet.",
							"scope": "global",
							"shortdesc": "Authorization scriptlet",
							"type": "string"
						}
					},
					{
						"backups.compression_algorithm": {
							"defaultdesc": "`gzip`",
							"longdesc": "Possible values are `bzip2`, `gzip`, `lz4`, `lzma`, `xz`, `zstd` or `none`.",
							"scope": "global",
							"shortdesc": "Compression algorithm to use for backups",
							"type": "string"
						}
					},
					{
						"instances.lxcfs.per_instance": {
							"defaultdesc": "`false`",
							"longdesc": "LXCFS is used to provide overlays for common `/proc` and `/sys`\nfiles which reflect the resource limits applied to the container.\n\nIt normally operates through a single file system mount on the host which is then shared by all containers.\nThis is very efficient but comes with the downside that a crash of LXCFS will break all containers.\n\nWith this option, it's now possible to run a LXCFS instance per\ncontainer instead, using more system resources but reducing the impact\nof a crash.",
							"scope": "global",
							"shortdesc": "Whether to run LXCFS on a per-instance basis",
							"type": "bool"
						}
					},
					{
						"instances.nic.host_name": {
							"defaultdesc": "`random`",
							"longdesc": "Possible values are `random` and `mac`.\n\nIf set to `random`, use the random host interface name as the host name.\nIf set to `mac`, generate a host name in the form `inc\u003cmac_address\u003e` (MAC without leading two digits).",
							"scope": "global",
							"shortdesc": "How to set the host name for a NIC",
							"type": "string"
						}
					},
					{
						"instances.placement.scriptlet": {
							"longdesc": "When using custom automatic instance placement logic, this option stores the scriptlet.\nSee {ref}`clustering-instance-placement-scriptlet` for more information.",
							"scope": "global",
							"shortdesc": "Instance placement scriptlet for automatic instance placement",
							"type": "string"
						}
					},
					{
						"network.ovn.ca_cert": {
							"defaultdesc": "Content of `/etc/ovn/ovn-central.crt` if present",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL certificate authority",
							"type": "string"
						}
					},
					{
						"network.ovn.client_cert": {
							"defaultdesc": "Content of `/etc/ovn/cert_host` if present",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL client certificate",
							"type": "string"
						}
					},
					{
						"network.ovn.client_key": {
							"defaultdesc": "Content of `/etc/ovn/key_host` if present",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN SSL client key",
							"type": "string"
						}
					},
					{
						"network.ovn.integration_bridge": {
							"defaultdesc": "`br-int`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVS integration bridge to use for OVN networks",
							"type": "string"
						}
					},
					{
						"network.ovn.northbound_connection": {
							"defaultdesc": "`unix:/run/ovn/ovnnb_db.sock`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVN northbound database connection string",
							"type": "string"
						}
					},
					{
						"network.ovs.connection": {
							"defaultdesc": "`unix:/run/openvswitch/db.sock`",
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OVS socket path",
							"type": "string"
						}
					},
					{
						"storage.backups_volume": {
							"longdesc": "Specify the volume using the syntax `POOL/VOLUME`.",
							"scope": "local",
							"shortdesc": "Volume to use to store backup tarballs",
							"type": "string"
						}
					},
					{
						"storage.images_volume": {
							"longdesc": "Specify the volume using the syntax `POOL/VOLUME`.",
							"scope": "local",
							"shortdesc": "Volume to use to store the image tarballs",
							"type": "string"
						}
					}
				]
			},
			"oidc": {
				"keys": [
					{
						"oidc.audience": {
							"longdesc": "This value is required by some providers.",
							"scope": "global",
							"shortdesc": "Expected audience value for the application",
							"type": "string"
						}
					},
					{
						"oidc.claim": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OpenID Connect claim to use as the username",
							"type": "string"
						}
					},
					{
						"oidc.client.id": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OpenID Connect client ID",
							"type": "string"
						}
					},
					{
						"oidc.issuer": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "OpenID Connect Discovery URL for the provider",
							"type": "string"
						}
					},
					{
						"oidc.scopes": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "Comma separated list of OpenID Connect scopes",
							"type": "string"
						}
					}
				]
			},
			"openfga": {
				"keys": [
					{
						"openfga.api.token": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "API token of the OpenFGA server",
							"type": "string"
						}
					},
					{
						"openfga.api.url": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "URL of the OpenFGA server",
							"type": "string"
						}
					},
					{
						"openfga.store.id": {
							"longdesc": "",
							"scope": "global",
							"shortdesc": "ID of the OpenFGA permission store",
							"type": "string"
						}
					}
				]
			}
		}
	}
}